# 茶心阁小程序开发计划

> 附加说明：下面新增节说明如何在运行环境启用第三方大模型（示例：Claude Sonnet 4.5），该说明**不包含任何 git 操作**，适合由运维或有控制台权限的同事直接在环境中执行。

## 一、项目概述

基于需求文档分析，茶心阁是一个集在线商城、多门店点单（堂食/外卖）、分销系统、会员管理、合伙人管理于一体的综合性茶文化平台。


每次阅读开发计划，浏览项目开发总结.md,项目完成总结.md
项目完成情况写入 项目开发总结.md,项目完成总结.md
项目开发结构按照 项目开发总结.md处理


**技术架构：**
- 前端：微信小程序 + 管理后台Web应用
- 后端：Go 1.21 + 微服务架构
- 数据库：MySQL + Redis
- 支付：微信支付 + 支付宝
- 消息推送：微信公众号
- 第三方服务：配送平台、短信服务

---

## 测试与运行约定

- **运行方式约定（重要）：** 本开发计划明确要求**不使用 Docker**。开发与联调时请在宿主机或虚拟机上直接运行 MySQL/Redis/RabbitMQ 和服务进程，或者使用系统级服务管理（如 `systemd` / Windows 服务）；不得使用 `docker`、`docker-compose` 或容器镜像作为开发/测试的运行方式。若确有必要使用容器化方案，需事先向项目负责人申请并在变更单中记录审批结果。
- **运行方式约定（重要）：** 本开发计划明确要求**不使用 Docker**。开发与联调时请在宿主机或虚拟机上直接运行 MySQL/Redis/RabbitMQ 和服务进程，或者使用系统级服务管理（如 `systemd` / Windows 服务）；不得使用 `docker`、`docker-compose` 或容器镜像作为开发/测试的运行方式。若确有必要使用容器化方案，需事先向项目负责人申请并在变更单中记录审批结果。

- **服务重启约定（重要）：** 在日常开发/联调中，重启服务时**不再额外验证** Redis、MySQL、RabbitMQ 的启动状态（跳过端口/进程检查）；操作应直接以启动/重启服务为准（例如 Windows 下使用 `Restart-Service`、Linux 下使用 `systemctl restart` 或直接启动可执行程序）。如需后续验证请在变更单中说明并经负责人批准。
- **测试目录：** 已将演示/测试代码的集中副本放在 `test/tea-api/` 以便统一查看；保留 `tea-api/test/` 作为模块本地测试集合。
- **注意：** 为避免 Go `internal` 可见性冲突，从仓库根运行 `go test ./...` 时顶层 `test/tea-api/` 中的文件被标记为 `//go:build ignore` 并会被跳过。请在需要运行模块级测试时进入对应子模块目录（例如 `tea-api/`）运行 `go test ./...`。
- **中央测试服务（默认值，可用 TEA_ 环境变量覆盖）：**
    - MySQL: `root:my-secret-pw@tcp(10.8.0.14:3310)/tea_shop?charset=utf8mb4&parseTime=True&loc=Local`
    - Redis: `10.8.0.14:6379` 密码 `123456`
    - RabbitMQ: `amqp://guest:guest@10.8.0.14:5672/`

**测试环境2（本地开发快速切换）**
- MySQL: `root:gs963852@tcp(127.0.0.1:3306)/tea_shop?charset=utf8mb4&parseTime=True&loc=Local`
- Redis: `127.0.0.1:6379` 密码：无
- RabbitMQ: `amqp://guest:guest@127.0.0.1:5672/`

说明：仓库根目录已提供 PowerShell 辅助脚本 `scripts\use-test-env2.ps1`（用于在当前 PowerShell 会话设置环境变量）以及 `scripts\run-tests-test2.ps1`（先设置环境变量再执行 `go test ./...`）。这两者可用于在本机快速把测试切换到 测试环境2。

- **运行示例（PowerShell）：**
```powershell
cd E:\project\tea
# 注意：仓库已禁止使用 SQLite 回退，强制使用 MySQL
$env:TEA_DSN='root:gs963852@tcp(127.0.0.1:3306)/tea_shop?charset=utf8mb4&parseTime=True&loc=Local'
$env:REDIS_ADDR='127.0.0.1:6379'
$env:REDIS_PASSWORD=''
$env:RABBITMQ_ADDR='amqp://guest:guest@127.0.0.1ex:5672/'
go test ./... 2>&1 | Tee-Object -FilePath test-run.log
```

将 `TEA_` 前缀的环境变量用于覆盖默认配置（例如 `TEA_DSN`、`TEA_DATABASE_HOST` 等）。代码中已统一使用 `pkg/env/env.go` 的 `env.Get(key, default)` 读取环境配置。


## 二、WX-FE 微信小程序开发计划

### 2.1 技术框架选择
- **开发框架：** 微信原生小程序 + WeUI 组件库
- **状态管理：** Mobx-miniprogram
- **网络请求：** 封装 wx.request
- **UI框架：** 参照瑞幸咖啡小程序，采用简约疗愈风格

### 2.2 功能模块划分

#### 2.2.1 模块一：用户认证模块
**功能：** 登录注册、用户信息管理
**实现步骤：**
1. 创建登录页面和注册页面
2. 实现微信授权登录
3. 实现手机号验证码登录
4. 用户信息存储和状态管理
5. 权限控制和身份验证

#### 2.2.2 模块二：首页模块
**功能：** 轮播图、会员展示、金刚区、商品推荐
**实现步骤：**
1. 设计首页布局结构
2. 实现轮播图组件（支持跳转链接）
3. 会员状态展示组件
4. 金刚区功能入口（堂食、外卖、商城）
5. 推荐商品列表展示
6. 广告位组件实现

#### 2.2.3 模块三：商城模块
**功能：** 商品展示、分类筛选、购物车、订单
**实现步骤：**
1. 商品分类页面（按茶类、产区、用途分类）
2. 商品列表页面（筛选、排序功能）
3. 商品详情页面（图片轮播、规格选择、分享功能）
4. 购物车功能实现
5. 订单确认页面
6. 支付功能集成

#### 2.2.4 模块四：门店服务模块
**功能：** 门店列表、门店详情、堂食外卖点单
**实现步骤：**
1. 获取用户地理位置
2. 门店列表页面（按距离排序）
3. 门店详情页面（基本信息、商品服务）
4. 堂食点单功能（扫码点餐、购物车、支付）
5. 外卖点单功能（配送地址、配送范围检查）
6. 订单状态跟踪

#### 2.2.5 模块五：个人中心模块
**功能：** 用户信息、订单管理、钱包、积分、分销
**实现步骤：**
1. 个人信息页面设计
2. 会员等级展示和升级功能
3. 订单管理（全部状态订单列表）
4. 钱包功能（余额、茶币、提现）
5. 积分系统（积分商城、积分记录）
6. 优惠券管理
7. 分销推广功能（分享海报生成）

#### 2.2.6 模块六：分销系统模块
**功能：** 推广链接生成、佣金计算、团队管理
**实现步骤：**
1. 推广关系绑定逻辑
2. 分享海报生成功能
3. 推广数据统计页面
4. 佣金记录和提现功能
5. 团队层级展示

### 2.3 开发时间规划
- **第1-2周：** 项目初始化、基础组件开发
- **第3-4周：** 用户认证、首页模块
- **第5-7周：** 商城模块开发
- **第8-9周：** 门店服务模块
- **第10-12周：** 个人中心、分销系统
- **第13-14周：** 测试优化、上线准备

---

## 三、Admin-FE 管理后台开发计划

### 3.1 技术框架选择
- **前端框架：** Vue 3 + TypeScript
- **UI组件库：** Element Plus
- **状态管理：** Pinia
- **路由管理：** Vue Router 4
- **HTTP客户端：** Axios
- **构建工具：** Vite
- **图表库：** ECharts

### 3.2 功能模块划分

### 3.1.1 管理后台界面布局与权限展示约定

- 布局说明：后台管理界面采用标准的左右布局（响应式）。左侧为垂直导航菜单（菜单树），右侧为主内容区：以列表为主的展示区域，支持详情面板、弹窗表单用于新增/修改，以及操作按钮列（查看/编辑/删除/导出/更多）。
- 左侧菜单职责：
    - 用于模块导航（例如：首页/商品/分类/门店/订单/财务/用户/日志/系统配置）。
    - 菜单项的可见性由后端的 RBAC 权限决定，前端根据登录用户的 `role` + `permissions` 动态渲染菜单树。
    - 菜单应支持折叠/展开、当前选中高亮和面包屑同步，便于用户定位当前页面层级。
- 右侧主区职责：
    - 默认以列表视图展示（表格、分页、筛选、排序、导出）。
    - 列表项支持内联操作（如快速编辑/发货/退款/查看日志）和弹窗级操作（详情/编辑/批量处理）。
    - 新增/修改通过模态或侧滑面板承载，完成后刷新列表或按局部变更更新缓存。
- 权限展示与操作控制：
    - 菜单级可见性：后端返回的菜单树或权限字典决定哪些菜单项在左侧显示（例如：门店管理员看不到“系统设置”）。
    - 路由守卫：前端路由在导航前应校验用户权限，未授权访问应跳转到“无权限”提示页或回到首页。
    - 按钮/操作级别：列表中每个操作按钮（编辑/删除/导出/退款 等）在渲染前要根据权限判断可见/可用；即使隐藏了按钮，后端接口也必须做二次鉴权，避免越权请求。
    - 数据权限：对诸如门店管理员这类有数据范围限制的角色，需要在后端践行数据域隔离（查询 API 接受门店范围过滤），并在前端限制筛选范围与默认查询条件。
- UX / 可用性约定：
    - 菜单切换/列表操作应保持低于 2s 的交互响应（接口未命中时给出友好错误与重试入口）。
    - 对于会影响资金或订单状态的重要操作（退款、手动对账、后台取消），需二次确认弹窗并记录操作日志。
    - 批量操作需展示进度（成功/失败计数）并允许导出失败项用于后续人工处理。
- 前后端协作建议：
    - 后端提供菜单/权限字典接口（例如 `/api/v1/admin/menus` 与 `/api/v1/admin/me/permissions`），前端按返回的数据动态渲染并缓存权限信息。
    - 推荐在登录成功后立即拉取权限字典并存入内存（或 sessionStorage），用于路由守卫与按钮可见性判断；如权限变更需提供刷新权限接口。

示例角色与左侧菜单可见性（示例，仅供参考）：

- **超级管理员 (5)**：全部菜单可见，支持所有操作；
- **门店管理员 (4)**：可见：门店、门店商品、订单（该门店范围）、库存、基础数据；不可见：系统设置、全量用户管理（仅能查看本门店相关用户）；
- **合伙人 (3)**：可见：商品管理、数据看板、用户统计；不可见：门店管理、系统配置、资金敏感操作；
- **店员 (2)**：可见：门店订单列表（仅操作订单的基础动作，如发货/标记完成）、门店商品；不可见：导出大数据/财务结算操作；
- **会员/普通用户 (1/0)**：仅能访问受限的自助界面或无后台菜单（如支持则仅能查看个人相关数据）。

注：以上前端展示控制是为提升用户体验与减少误操作，所有关键接口必须在后端做权限校验以保证安全性。

#### 3.2.1 模块一：系统基础模块
**功能：** 登录认证、权限管理、菜单管理
**权限管理模式：** RBAC（基于角色的访问控制）+ 层级权限控制
**实现步骤：**
1. 登录页面设计和实现
    - 后台登录页需支持按角色区分登陆后视图（登录后根据角色跳转至对应首页），并在登录表单中以只读方式展示角色ID映射说明（用于调试）：合伙人=3，门店管理员=4，超级管理员=5。
2. JWT token认证机制
3. RBAC权限系统设计
    - 角色定义（含编号映射）：超级管理员(5)、门店管理员(4)、合伙人(3)、店员(2)、会员(1)、普通用户(0)
   - 权限资源定义：菜单权限、操作权限、数据权限
   - 角色权限关联表设计
4. 权限路由守卫（基于角色和权限）
5. 动态菜单渲染（根据用户角色显示对应菜单）
6. 数据权限控制（门店管理员只能查看自己门店数据）
7. 操作权限验证（按钮级别权限控制）

#### 3.2.2 模块二：数据看板模块
**功能：** 数据统计、图表展示、实时监控
**实现步骤：**
1. 首页数据看板设计
2. 销售数据统计图表
3. 用户行为分析图表
4. 实时订单监控
5. 财务数据展示

#### 3.2.3 模块三：商品管理模块
**功能：** 商品CRUD、分类管理、库存管理
**实现步骤：**
1. 商品分类管理页面
2. 商品列表页面（搜索、筛选、分页）
3. 商品新增/编辑页面（富文本编辑器）
4. 商品规格属性管理
5. 库存管理和预警
6. 商品批量操作功能

#### 3.2.4 模块四：订单管理模块
**功能：** 订单处理、发货管理、售后处理
**实现步骤：**
1. 订单列表页面（多条件筛选）
2. 订单详情页面
3. 发货管理功能
4. 退货退款处理
5. 订单状态跟踪
6. 批量处理功能

#### 3.2.5 模块五：门店管理模块
**功能：** 门店信息管理、门店管理员分配
**实现步骤：**
1. 门店列表管理页面
2. 门店信息编辑页面
3. 门店管理员分配
4. 门店业绩统计
5. 门店商品管理权限

#### 3.2.6 模块六：用户管理模块
**功能：** 会员管理、合伙人管理、等级权益设置
**实现步骤：**
1. 用户列表管理页面
2. 会员等级配置页面
3. 合伙人层级管理
4. 用户权益设置
5. 黑白名单管理

#### 3.2.7 模块七：营销管理模块
**功能：** 广告管理、优惠券管理、活动管理
**实现步骤：**
1. 轮播图广告管理
2. 优惠券创建和发放
3. 营销活动管理
4. 分销规则配置
5. 佣金比例设置

#### 3.2.8 模块八：财务管理模块
**功能：** 财务统计、佣金结算、提现管理
**实现步骤：**
1. 财务流水统计
2. 佣金结算管理
3. 提现申请审核
4. 财务报表生成
5. 对账功能实现

### 3.3 开发时间规划
- **第1-2周：** 项目搭建、基础组件、权限系统
- **第3-4周：** 数据看板、商品管理模块
- **第5-6周：** 订单管理、门店管理模块
- **第7-8周：** 用户管理、营销管理模块
- **第9-10周：** 财务管理、系统设置模块
- **第11-12周：** 测试优化、性能调优

---

### 3.4 阶段进展与下一步（实操对齐）

为快速联调与验收，当前 Admin-FE 采用「轻量单页 HTML/JS」的 MVP 实现，已与 API-Server 对通并可直接在浏览器本地打开使用。后续可在保持页面功能的同时，逐步迁移到 3.1 所述的 Vue 3 + TS 技术栈。

【已完成（M1-M3 最小可用）】
- 环境切换与检测：API_BASE 切换（8082/自定义）与一键“检测接口”。
- 统一鉴权与用户栏：/auth/login 与 /auth/me 接入；显示当前用户、退出登录。
- 健康状态轮询：每 10 秒自动探活 /health，状态点在线/离线实时更新。
- 标签记忆：记忆最近打开的标签页，刷新后恢复。
- 用户管理：/admin/users 列表（本地过滤、分页、CSV 导出带 BOM）。
- 商品管理：列表分页、CSV 导出、模态框新增/编辑、删除；与分类联动显示。
- 分类管理：列表分页、CSV 导出、模态框新增/编辑、删除（含图标）。
 - 门店管理：门店列表分页、名称关键字过滤、选中门店后查看订单统计与库存绑定列表。
 - 门店库存绑定与选品器：支持单个商品绑定/更新库存与价格，新增批量绑定弹窗，一次性绑定多个商品 ID 并统一设置库存/覆盖价；在门店面板中增加“门店选品器”，可按商品名称搜索全量商品并一键加入当前门店；在批量绑定弹窗中支持为每个商品单独设置库存/覆盖价，也可通过“统一库存/统一覆盖价”快速配置整批商品，并在批量请求过程中显示实时进度与允许中途取消。
 - 门店订单列表与操作工具：在门店面板内提供发货、完成、取消（用户/后台）、退款全链路操作；新增“门店订单列表”（可按订单ID、状态、时间筛选，支持快捷状态按钮与导出 CSV/XLSX），列表行可一键带入订单ID到操作区并自动拉取订单详情。
 - 门店与财务联动：在门店订单的详情区提供“在财务页查看”入口，可自动跳转到财务页并按订单ID查询对应操作日志；在财务页中提供按门店汇总视图（基于 /admin/finance/summary 的 store 维度），可一键跳转回对应门店面板查看订单与库存。
 - 门店与财务/用户联动：在门店订单的详情区提供“在财务页查看”“查看用户”等入口，可自动跳转到财务页并按订单ID查询对应操作日志，或跳转到用户管理页查看该用户概览；在财务页中提供按门店汇总视图（基于 /admin/finance/summary 的 store 维度），以及从支付流水、提现记录、操作日志等视图跳转至用户管理的“查看用户”入口，可一键跳转回对应门店或用户面板查看详情。
 - 财务查询与导出：退款、操作日志、访问日志、支付流水、提现记录、对账汇总与差异等查询列表，支持分页与 CSV/XLSX 导出，导出统一采用带 BOM 的命名规则（模块_时间戳），并为所有查询/导出按钮接入统一的 Loading/禁用态工具以避免重复提交。

【下一阶段建议（M4-M5）】
- 门店与订单联动
    - 门店商品选品器增强：已完成多选勾选、批量加入门店，以及“统一库存/统一覆盖价 + 逐行单独设置”的批量配置能力；后续可在此基础上继续考虑按分类/标签过滤以适配更多 SKU。
    - 门店订单与财务闭环：在现有门店订单列表与财务联动基础上，增加更多快捷入口（例如从财务门店汇总直接筛选该门店某时间段订单），并补充针对异常订单的一键排查路径。
- 财务工具完善
    - 导出体验优化：在现有 Loading/禁用态与 CSV/XLSX 能力基础上，增加导出队列/任务进度提示、失败重试按钮与最大行数提示。
        - 【已实现子项】最大行数提示：在退款记录、财务操作日志、访问日志、支付流水、提现记录等列表导出前，如当前查询结果条数超过预设阈值（例如 5000 条），前端会弹出确认对话框提示“导出可能导致 Excel 卡顿，建议先缩小时间范围”，由运营确认后再继续导出；后续如有需要，可在后端补充导出队列/任务进度与失败重试能力。
    - 【部分已落地】查询表单校验与快捷时间范围：在退款记录、财务操作日志、访问日志、支付流水、提现记录、对账差异等财务查询表单中统一增加“最近7天/本月”快捷按钮，并在前端对开始/结束日期做基本区间校验（开始日期不得晚于结束日期），后续如有需要可继续推广到其他模块或增加更细粒度的校验规则。
    - 门店汇总视图优化：在当前按门店聚合视图基础上，支持按净额/退款金额/订单数等维度灵活排序，并增加导出门店维度汇总的能力，便于运营做跨门店对比。
        - 【已实现】在 Admin-FE 的“按门店汇总”区域中，新增“导出汇总”按钮，通过前端读取当前表格数据生成带 BOM 的 CSV 文件（包含门店、订单数、支付笔数、支付金额、退款笔数、退款金额、净额），文件名统一为 `store_summary_时间戳.csv`，方便运营将当前筛选结果导出做对比分析；同时在前端对返回的聚合结果根据所选排序字段（实收金额/净额/退款金额降序）再做一次兜底排序，并在界面文案中提示“当前数据按下拉选择维度降序排列，如需切换排序请调整下拉框后重新查询”。
- 日志分析
    - 访问/操作日志增加高级筛选（多选 Method、状态码区间、路径包含排除）。
    - 导出模板优化（字段顺序、别名、本地时间格式）。
- 体验一致性
    - 【基础版已落地】错误提示与 Loading/禁用态统一：所有重要操作按钮均接入 `beginBtnLoading`/`endBtnLoading`，主要列表均有 `...-loading` 区域与“加载失败：xxx”统一提示文案；后续如有需要，可进一步抽取 `showListError/normalizeError` 等通用工具函数作为增量优化。
    - 【已落地】导出文件命名规范统一：各模块导出文件均按“模块_时间戳”命名，统一添加 BOM 以兼容 Excel，前端实现已与当前导出入口全部接入。

【用户管理精确查询演进（方向A 已落地）】

- 现状（已实现）：
    - Admin-FE 的【用户管理】标签页通过 `/api/v1/admin/users` 从 `tea-api` 主服务获取用户列表，数据缓存在 `allUsersCache` 中，仍支持在本地缓存中按昵称/手机号前端过滤；
    - 从门店订单详情、支付流水、提现记录、财务操作日志点击“查看用户”时，会调用 `goToUserFromStore`/`goToUserFromFinance`，先切换到【用户管理】标签，再通过 `focusUserById(userId)` 尝试按 user_id 精确定位；
    - 成功命中时，用户列表只展示该用户一条记录，并在顶部 `users-precise-hint` 显示“已按 user_id 精确定位”的提示，统计文案更新为“共 1 条（精确匹配 user_id = X）”；
    - 当后端返回空或接口异常时，前端在 `users-precise-hint` 提示“未能按 user_id 精确定位，已回退到本地过滤模式”，并回退到原有“跳转 + 聚焦搜索框，由运营按手机号/昵称过滤”的模式。
- 后端接口实现（tea-api）：
    - 在 `tea-api` 主服务中扩展 `/api/v1/admin/users`：
        - 当 **不带** `user_id` 时，保持原有分页行为，返回带有分页元信息的用户列表；
        - 当 **带** `user_id` 时，优先调用 `UserService.GetUserInfo`，并返回 data 数组长度为 0 或 1：
            - `GET /api/v1/admin/users?user_id=123` → `{ data: [userInfo] }` 或 `{ data: [] }`；
        - 对于非法 `user_id`，返回参数错误提示，避免异常污染日志；
    - 接口在认证与权限控制上沿用原有 admin 路由配置（需要登录且具备 admin 角色），与其他管理类接口保持一致。
- 前端改造要点（Admin-FE）：
    - `loadUsers()`：将原本指向临时 API-Server 的 `/admin/users` 调用，统一改为 `/api/v1/admin/users`，与主服务对齐；
    - `focusUserById(userId)`：优先调用 `/api/v1/admin/users?user_id=xxx`，命中时仅渲染返回的单条记录并展示“精确定位”提示；未命中或接口异常时，自动回退到本地缓存过滤；
    - `goToUserFromStore` / `goToUserFromFinance`：在切换到【用户管理】标签后，先调用 `focusUserById(userId)`，若精确定位失败则设置搜索框 placeholder 为“可按昵称/手机号查找用户（触发源 user_id = X）”并聚焦输入框，保留原有操作习惯。
- 渐进式演进状态：
    - 阶段一（预留前端能力）：已完成 —— Admin-FE 中的 `focusUserById` 与跳转 helper 已实现，并具备回退策略；
    - 阶段二（主服务后端实现）：已完成 —— `tea-api` 主服务中的 `/api/v1/admin/users` 已支持 `user_id` 精确过滤，并与 Admin-FE 前端联调验证；
    - 阶段三（文档与手册同步）：已完成 —— 本开发计划与《运营排障手册》中均已补充“user_id 精确定位”的使用说明，将原先的“跳转+提示”升级为“一键定位 + 回退策略”。

【迁移与演进路径】
- 逐步按页面迁移到 Vue 3 + TS：优先迁移“用户管理”和“商品/分类”两页，保留后端接口不变以降低风险。
- 抽取通用组件：分页条、导出器、模态表单、请求封装、鉴权态管理。

【验收标准（节选）】
- 门店页：分页、筛选、选择后指标加载 < 2s；库存绑定支持单个与批量操作，批量绑定过程中有进度提示与错误收集。
- 财务页：导出 5k 行以内稳定，导出过程中按钮禁用且有 Loading 提示，导出失败时给出可理解的重试与排障提示。
- 日志页：高级筛选正确过滤，导出字段与表头符合字段字典。
- 订单操作区：所有发货/完成/取消/退款操作均具备 Loading/禁用态与内联结果提示，避免误触和重复提交；从门店订单列表或财务页跳转到订单操作区时，订单ID自动带入且详情区能正常展示订单信息。
- 一致性：所有导出均含 BOM，分页/禁用/Loading 行为一致，错误提示文案风格统一。

【M4 完成清单（草案）】

- 门店与订单联动
    - [ ] 门店面板中可直接查看该门店的订单列表（支持按日期、状态筛选、快捷状态按钮），并与现有订单统计数据保持一致。
    - [ ] 从门店维度的订单列表点击单条记录，可一键回到当前“订单操作工具”区域并自动填充订单 ID，同时右侧详情区自动拉取并展示该订单信息。
    - [ ] 从财务页按门店汇总视图点击某门店行，可以一键跳转至对应门店面板，订单统计/订单列表/库存数据在随机抽样下与 API-Server 对账结果一致；从支付流水、提现记录、操作日志等视图点击“查看用户”，可以跳转到用户管理标签页并辅助运营快速定位相关用户。

- 门店商品选品器
    - [ ] 在批量绑定弹窗中支持按商品名称/分类搜索并多选商品，而非仅手动输入商品 ID。
    - [ ] 批量选中的商品可一次性设置统一库存与覆盖价，并在执行过程中展示成功/失败计数与当前进度。
    - [ ] 批量/单个绑定成功后，门店商品列表中的库存与价格能够即时刷新，无需手动刷新整页。

- 财务工具体验
    - [ ] 所有导出操作（退款、支付、访问日志、操作日志、提现、对账）在导出过程中按钮禁用并展示“导出中...”类文案。
    - [ ] 当导出结果超过最大行数限制时，界面给出清晰提示，并建议缩小时间范围或增加筛选条件。
    - [ ] 导出失败时，前端展示错误原因，并提供“重试导出”入口或明确的下一步操作建议。

【典型排障路径示例（运营视角）】

以下路径示例均基于当前 Admin-FE MVP 的真实能力设计，目的是让运营/测试同事可以「从问题现场」快速跳转到合适的后台视图完成排查与记录。

1）从「门店投诉订单异常」出发
- 场景：门店店员反馈某订单状态不对（例如小程序显示已支付但门店看不到、或配送状态异常）。
- 建议排查步骤：
    1. 在 Admin-FE 打开【门店】标签页，使用门店列表按名称搜索并选中对应门店，确认右侧门店面板加载完成（订单统计与库存数据正常显示）。
    2. 在该门店面板的「门店订单列表」中，根据门店提供的订单号或时间范围，使用订单ID/状态/日期筛选出疑似订单；如不确定具体订单，可先用时间+状态（如「仅已付款」）缩小范围。
    3. 在列表中点击该订单所在行，或点击操作列的「带入并查看」按钮，让订单 ID 自动带入上方「订单操作工具」区域，并自动拉取右侧订单详情。
    4. 在订单详情中查看关键信息（支付方式、金额、门店、配送信息等），如需进一步核实资金流向，点击「在财务页查看」跳转到财务标签页，并自动按订单ID查询该订单的支付/退款操作日志。
    5. 在财务标签页确认该订单的支付流水、退款记录是否与小程序端展示一致，必要时导出相关流水记录（CSV/XLSX）并附在排查记录中。
    6. 如怀疑为单个用户账户问题，可在订单详情中点击「查看用户」，跳转到【用户管理】标签页，聚焦搜索框后按手机号/昵称进一步筛选该用户，结合其历史订单与钱包记录给出处理建议。

2）从「财务对账差异」出发
- 场景：财务在日常对账时发现某个结算周期内门店/渠道的收入与第三方对账单不一致，需要定位具体门店和订单。
- 建议排查步骤：
    1. 在 Admin-FE 打开【财务】标签页，先使用对账汇总功能，按日期范围和支付方式进行汇总，并对比外部对账单确认差异规模（订单数/金额级别）。
    2. 切换到「按门店汇总」视图，选择同样的日期范围和支付方式，查询各门店的订单数、支付金额、退款金额和净额，优先关注差异明显的门店。
    3. 在门店汇总表中，点击存在差异的某门店行的「查看门店详情」，一键跳转到【门店】标签页并自动选中该门店，核对门店面板中的订单统计与门店汇总数据是否一致。
    4. 在该门店的「门店订单列表」中，结合对账周期的日期范围与订单状态（如仅已完成/仅已退款）进行筛选，导出订单列表（CSV/XLSX），与第三方对账单进行逐笔比对。
    5. 如在对账过程中发现个别订单的支付流水异常（例如支付成功但未记账/记账金额不一致），可在财务标签页的「支付流水」中按订单ID或时间段查询，对单条记录点击「查看订单」「查看日志」进一步追踪链路。
    6. 若差异集中在个别用户（例如频繁退款或多笔异常支付），可直接在支付流水、提现记录或操作日志中点击「查看用户」进入【用户管理】标签页，聚焦该用户进行历史行为审查，并将结论记录在财务排查文档中。

3）从「用户投诉资金问题」出发
- 场景：用户反馈「我付了钱没看到订单」「余额/茶币/佣金对不上」，需要从用户视角进行纵向追踪。
- 建议排查步骤：
    1. 先在外部渠道（客服系统/聊天记录）确认用户提供的关键信息：手机号、昵称、疑似订单时间段和金额。
    2. 在 Admin-FE 打开【用户管理】标签页，使用搜索框按手机号或昵称对 `allUsersCache` 进行前端过滤，找到疑似用户，必要时通过创建时间、地区等辅助信息进行人工甄别。
    3. 在用户管理列表中查看该用户的基础信息和历史订单数、钱包/茶币/佣金相关字段，初步判断问题属于「订单缺失」还是「账务展示错误」。
    4. 如怀疑某一笔订单缺失，可根据用户提供的时间段与金额，在【订单/门店】相关视图中按时间+金额+门店进行组合筛选，尝试定位对应订单，并通过「在财务页查看」确认支付流水与退款情况。
    5. 如问题集中在提现或佣金结算，可在【财务】标签页的「提现记录」「佣金/分润相关流水」中按时间范围和金额过滤，找到该用户的相关记录；在记录行中点击「查看用户」可随时跳回【用户管理】标签页，保持对该用户整体资产状况的全局视图。
    6. 排查完成后，可将用户侧的「时间/金额/渠道」与后台查到的「订单ID/支付流水号/提现单号」对应起来，形成一条明确的说明路径，方便客服一次性回复用户并留下内部 SOP 样例。

- 日志与排障
    - [ ] 操作日志与访问日志支持一键填充“最近7天 / 本月”等快捷时间范围。
    - [ ] 常用组合筛选（如按 order_id + operation、按 status code 区间）在随机抽样下验证与后端原始日志一致。
    - [ ] 导出的日志字段顺序、字段名与内部字段字典一致，便于对接外部分析/BI 工具。

【本地联调验证 - 进展】

- 已在本地完成 Admin-FE 与 API-Server 的联调验证：
    - 后端 `API-Server` 已在本地启动并监听 `:8082`，登录接口 `POST /auth/login` 能返回开发用 JWT（包含 `role` / `name` / `exp` 等字段）。
    - 前端 Admin-FE 已能通过真实的 `POST /auth/login` 完成登录流程；使用自动化 Playwright 脚本在无头模式下完成登录，验证：
        - `localStorage.tea_admin_token` 已被成功写入（JWT 已保存）;
        - 登录后前端成功拉取并渲染侧栏菜单（示例项：`首页`）。
    - 本次验证流程包括：启动 `API-Server`（`go run main.go auth.go`）、启动 Admin-FE 静态服务（`python -m http.server 8000`）以及运行 `tools/browser-login/login-test.js`（Playwright），用于自动化登录与 token 检查。

以上验证证明当前开发版的鉴权与动态菜单拉取在本地环境可用，建议将此自动化脚本保留为回归验证工具并纳入日常联调流程。

**自动化回归（建议）**

- 将 `tools/browser-login/login-test.js` 作为一个轻量 smoke 测试保留在仓库中，供每次本地联调或 CI 触发时执行；该脚本：
    - 在无头模式下打开 Admin-FE，执行登录并断言 `localStorage.tea_admin_token` 已保存；
    - 验证侧栏菜单被拉取并包含预期项（如 `首页`）；
    - 生成一个 JSON 格式的测试报告（`tools/browser-login/report-*.json`），用于人工复查或集成到简单的 CI 报告中；
- 运行示例（本地调试）：
    ```powershell
    cd tools\browser-login
    npm install
    npx playwright install
    $env:ADMIN_FE_URL='http://localhost:8000'
    $env:TEST_USER='admin'
    $env:TEST_PASS='pass'
    node login-test.js
    ```

注：报告中会包含本次登录脚本读取到的 `localStorage.tea_admin_token` 字段（仅用于本地或受控测试环境），请勿把报告或其中的 token 上传到公开仓库或共享到不受信任的位置；在产线上请使用更加严格的凭据管理与审计流程。


## 四、API-Server 后端服务开发计划

### 4.1 技术框架选择
- **开发语言：** Go 1.21
- **Web框架：** Gin
- **ORM框架：** GORM
- **数据库：** MySQL 8.0 + Redis 7.0
- **消息队列：** RabbitMQ
- **日志框架：** Zap
- **配置管理：** Viper
- **API文档：** Swaggo
- **架构模式：** 单体应用 + 模块化分层架构
- **监控：** Prometheus + Grafana

### 4.2 系统架构设计

#### 4.2.1 单体应用模块划分
```
tea-api/
├── cmd/                    # 应用启动入口
├── internal/
│   ├── handler/           # HTTP处理器
│   ├── service/           # 业务逻辑层
│   ├── repository/        # 数据访问层
│   ├── model/             # 数据模型
│   └── middleware/        # 中间件
├── pkg/                   # 公共工具包
├── configs/               # 配置文件
├── docs/                  # 文档
└── scripts/               # 脚本
```

**业务模块划分：**
1. **用户模块 (user)**
2. **商品模块 (product)**
3. **订单模块 (order)**
4. **支付模块 (payment)**
5. **门店模块 (store)**
6. **营销模块 (marketing)**
7. **分销模块 (distribution)**
8. **消息模块 (message)**
9. **外卖对接模块 (delivery)**
10. **访问日志模块 (access-log)**

### 4.3 功能模块划分

#### 4.3.1 模块一：基础服务模块
**功能：** 项目初始化、公共组件、中间件
**实现步骤：**
1. 项目结构初始化
   ```
   tea-api/
   ├── cmd/          # 服务启动入口
   ├── internal/     # 私有代码
   ├── pkg/          # 公共代码
   ├── configs/      # 配置文件
   ├── docs/         # 文档
   └── scripts/      # 脚本
   ```
2. 数据库连接池配置
3. Redis连接配置
4. JWT中间件实现
5. 日志中间件实现
6. CORS跨域处理
7. 限流中间件实现
8. 统一错误处理

#### 4.3.2 模块二：用户服务模块
**功能：** 用户认证、用户信息管理、权限控制
**权限管理架构：** RBAC + 数据权限分离
**实现步骤：**
1. 权限相关表结构设计
   ```sql
   -- 角色表
   CREATE TABLE roles (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '角色唯一标识',
       name VARCHAR(50) NOT NULL COMMENT '角色名称',
       code VARCHAR(50) UNIQUE NOT NULL COMMENT '角色编码',
       description VARCHAR(200) COMMENT '角色描述',
       sort INT DEFAULT 0 COMMENT '排序',
       status TINYINT DEFAULT 1 COMMENT '状态：0禁用 1启用',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       INDEX idx_uid (uid),
       INDEX idx_code (code),
       INDEX idx_is_deleted (is_deleted)
   );
   
   -- 权限资源表
   CREATE TABLE permissions (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '权限唯一标识',
       name VARCHAR(50) NOT NULL COMMENT '权限名称',
       code VARCHAR(100) UNIQUE NOT NULL COMMENT '权限编码',
       type TINYINT NOT NULL COMMENT '权限类型：1菜单 2按钮 3API',
       parent_id BIGINT DEFAULT 0 COMMENT '父权限ID',
       path VARCHAR(200) COMMENT '路径',
       method VARCHAR(10) COMMENT 'HTTP方法',
       icon VARCHAR(100) COMMENT '图标',
       sort INT DEFAULT 0 COMMENT '排序',
       status TINYINT DEFAULT 1 COMMENT '状态：0禁用 1启用',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       INDEX idx_uid (uid),
       INDEX idx_code (code),
       INDEX idx_parent_id (parent_id),
       INDEX idx_is_deleted (is_deleted)
   );
   
   -- 用户角色关联表
   CREATE TABLE user_roles (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '关联唯一标识',
       user_id BIGINT NOT NULL COMMENT '用户ID',
       role_id BIGINT NOT NULL COMMENT '角色ID',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       UNIQUE KEY uk_user_role (user_id, role_id),
       INDEX idx_uid (uid),
       INDEX idx_user_id (user_id),
       INDEX idx_role_id (role_id),
       INDEX idx_is_deleted (is_deleted)
   );
   
   -- 角色权限关联表
   CREATE TABLE role_permissions (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '关联唯一标识',
       role_id BIGINT NOT NULL COMMENT '角色ID',
       permission_id BIGINT NOT NULL COMMENT '权限ID',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       UNIQUE KEY uk_role_permission (role_id, permission_id),
       INDEX idx_uid (uid),
       INDEX idx_role_id (role_id),
       INDEX idx_permission_id (permission_id),
       INDEX idx_is_deleted (is_deleted)
   );
   ```
2. 权限管理中间件实现
   - JWT Token解析和验证
   - 用户权限缓存（Redis）
   - API接口权限验证
   - 数据权限过滤
3. 微信登录接口实现
4. 手机验证码登录
5. 用户信息CRUD接口
6. 角色权限管理接口
7. 推广关系绑定逻辑
8. 用户等级升级逻辑
9. 权限验证工具函数

#### 4.3.3 模块三：商品服务模块
**功能：** 商品管理、分类管理、库存管理
**实现步骤：**
1. 商品相关表结构设计
   ```sql
   -- 商品分类表
   CREATE TABLE categories (
       id INT PRIMARY KEY AUTO_INCREMENT,
       name VARCHAR(50),
       parent_id INT,
       level TINYINT,
       sort INT,
       status TINYINT
   );
   
   -- 商品表
   CREATE TABLE products (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       category_id INT,
       name VARCHAR(200),
       subtitle VARCHAR(300),
       main_image VARCHAR(500),
       sub_images TEXT,
       detail TEXT,
       price DECIMAL(10,2),
       stock INT,
       status TINYINT,
       created_at TIMESTAMP,
       updated_at TIMESTAMP
   );
   ```
2. 商品CRUD接口实现
3. 商品分类接口实现
4. 商品搜索和筛选接口
5. 库存管理接口
6. 商品规格属性管理
7. 商品图片上传处理

#### 4.3.4 模块四：订单服务模块
**功能：** 订单创建、订单处理、订单状态管理
**实现步骤：**
1. 订单相关表结构设计
   ```sql
   -- 订单表
   CREATE TABLE orders (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       order_no VARCHAR(50) UNIQUE,
       user_id BIGINT,
       store_id BIGINT,
       order_type TINYINT, -- 1:商城 2:堂食 3:外卖
       total_amount DECIMAL(10,2),
       pay_amount DECIMAL(10,2),
       status TINYINT,
       created_at TIMESTAMP,
       updated_at TIMESTAMP
   );
   
   -- 订单商品表
   CREATE TABLE order_items (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       order_id BIGINT,
       product_id BIGINT,
       quantity INT,
       price DECIMAL(10,2),
       total_amount DECIMAL(10,2)
   );
   ```
2. 订单创建接口实现
3. 订单状态流转管理
4. 订单列表查询接口
5. 订单详情接口
6. 订单取消/退款逻辑
7. 订单统计接口

#### 4.3.5 模块五：支付服务模块
**功能：** 支付集成、支付回调处理、退款处理、微信打款
**实现步骤：**
1. 微信支付SDK集成
2. 支付宝支付SDK集成
3. 统一支付接口设计
4. 支付回调处理
5. 退款接口实现
6. 微信企业付款到零钱功能
7. 微信打款记录和回调处理
8. 支付流水记录
9. 支付安全验证

**微信打款功能实现：**
```go
// 微信企业付款服务
type WechatTransferService struct {
    config *WechatPayConfig
    client *wechatpay.Client
}

type WechatPayConfig struct {
    AppID       string `json:"app_id"`
    MchID       string `json:"mch_id"`
    APIKey      string `json:"api_key"`
    CertPath    string `json:"cert_path"`
    KeyPath     string `json:"key_path"`
    NotifyURL   string `json:"notify_url"`
}

// 企业付款到零钱
func (s *WechatTransferService) TransferToWallet(ctx context.Context, req *TransferRequest) (*TransferResponse, error) {
    // 生成商户订单号
    partnerTradeNo := s.generateTradeNo()
    
    // 构建请求参数
    params := map[string]interface{}{
        "mch_appid":        s.config.AppID,
        "mchid":           s.config.MchID,
        "partner_trade_no": partnerTradeNo,
        "openid":          req.OpenID,
        "check_name":      "NO_CHECK", // 不校验真实姓名
        "amount":          int(req.Amount * 100), // 转换为分
        "desc":            req.Description,
        "spbill_create_ip": req.ClientIP,
        "nonce_str":       util.GenerateNonceStr(),
    }
    
    // 生成签名
    params["sign"] = s.generateSign(params)
    
    // 发送请求（需要双向证书认证）
    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: s.getTLSConfig(),
        },
        Timeout: 30 * time.Second,
    }
    
    url := "https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers"
    xmlData := s.mapToXML(params)
    
    resp, err := client.Post(url, "application/xml", strings.NewReader(xmlData))
    if err != nil {
        return nil, fmt.Errorf("微信打款请求失败: %v", err)
    }
    defer resp.Body.Close()
    
    // 解析响应
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取微信响应失败: %v", err)
    }
    
    result, err := s.parseXMLResponse(body)
    if err != nil {
        return nil, fmt.Errorf("解析微信响应失败: %v", err)
    }
    
    // 保存打款记录
    transferRecord := &WechatTransferRecord{
        UID:              s.generateUID(),
        WithdrawRequestID: req.WithdrawRequestID,
        UserID:          req.UserID,
        WechatOpenID:    req.OpenID,
        PartnerTradeNo:  partnerTradeNo,
        Amount:          req.Amount,
        DescText:        req.Description,
        SpbillCreateIP:  req.ClientIP,
        RequestData:     s.toJSON(params),
        ResponseData:    string(body),
    }
    
    if result["return_code"] == "SUCCESS" && result["result_code"] == "SUCCESS" {
        transferRecord.TransferStatus = 2 // 成功
        transferRecord.WechatOrderID = result["payment_no"]
        transferRecord.PaymentNo = result["payment_no"]
        if paymentTime, ok := result["payment_time"]; ok {
            transferRecord.PaymentTime = s.parseTime(paymentTime)
        }
    } else {
        transferRecord.TransferStatus = 3 // 失败
        if errMsg, ok := result["err_code_des"]; ok {
            transferRecord.Reason = errMsg
        }
    }
    
    if err := s.saveTransferRecord(ctx, transferRecord); err != nil {
        log.Error("保存微信打款记录失败", zap.Error(err))
    }
    
    return &TransferResponse{
        PartnerTradeNo: partnerTradeNo,
        PaymentNo:     result["payment_no"],
        Success:       result["return_code"] == "SUCCESS" && result["result_code"] == "SUCCESS",
        Message:       result["err_code_des"],
    }, nil
}

// 查询打款结果
func (s *WechatTransferService) QueryTransfer(ctx context.Context, partnerTradeNo string) (*TransferQueryResponse, error) {
    params := map[string]interface{}{
        "appid":            s.config.AppID,
        "mch_id":          s.config.MchID,
        "partner_trade_no": partnerTradeNo,
        "nonce_str":       util.GenerateNonceStr(),
    }
    
    params["sign"] = s.generateSign(params)
    
    url := "https://api.mch.weixin.qq.com/mmpaymkttransfers/gettransferinfo"
    xmlData := s.mapToXML(params)
    
    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: s.getTLSConfig(),
        },
        Timeout: 15 * time.Second,
    }
    
    resp, err := client.Post(url, "application/xml", strings.NewReader(xmlData))
    if err != nil {
        return nil, fmt.Errorf("查询微信打款状态失败: %v", err)
    }
    defer resp.Body.Close()
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    result, err := s.parseXMLResponse(body)
    if err != nil {
        return nil, err
    }
    
    response := &TransferQueryResponse{
        PartnerTradeNo: partnerTradeNo,
        Status:         result["status"],
        Reason:         result["reason"],
    }
    
    if paymentTime, ok := result["payment_time"]; ok {
        response.PaymentTime = s.parseTime(paymentTime)
    }
    
    return response, nil
}

// 处理打款结果回调
func (s *WechatTransferService) HandleTransferCallback(ctx context.Context, data []byte) error {
    // 记录回调日志
    callbackLog := &TransferCallbackLog{
        UID:          s.generateUID(),
        CallbackType: 1, // 微信
        CallbackData: string(data),
    }
    
    defer func() {
        if err := s.saveCallbackLog(ctx, callbackLog); err != nil {
            log.Error("保存打款回调日志失败", zap.Error(err))
        }
    }()
    
    // 解析回调数据
    result, err := s.parseXMLResponse(data)
    if err != nil {
        callbackLog.ErrorMessage = err.Error()
        return err
    }
    
    partnerTradeNo := result["partner_trade_no"]
    if partnerTradeNo == "" {
        callbackLog.ErrorMessage = "商户订单号为空"
        return fmt.Errorf("商户订单号为空")
    }
    
    // 查找对应的打款记录
    transferRecord, err := s.getTransferRecordByTradeNo(ctx, partnerTradeNo)
    if err != nil {
        callbackLog.ErrorMessage = fmt.Sprintf("查找打款记录失败: %v", err)
        return err
    }
    
    callbackLog.TransferRecordID = transferRecord.ID
    
    // 更新打款状态
    oldStatus := transferRecord.TransferStatus
    
    if result["return_code"] == "SUCCESS" && result["result_code"] == "SUCCESS" {
        transferRecord.TransferStatus = 2 // 成功
        transferRecord.PaymentNo = result["payment_no"]
        if paymentTime, ok := result["payment_time"]; ok {
            transferRecord.PaymentTime = s.parseTime(paymentTime)
        }
    } else {
        transferRecord.TransferStatus = 3 // 失败
        transferRecord.Reason = result["err_code_des"]
    }
    
    // 更新数据库记录
    if err := s.updateTransferRecord(ctx, transferRecord); err != nil {
        callbackLog.ErrorMessage = fmt.Sprintf("更新打款记录失败: %v", err)
        return err
    }
    
    // 如果状态发生变化，同步更新提现申请状态
    if oldStatus != transferRecord.TransferStatus {
        if err := s.updateWithdrawRequestStatus(ctx, transferRecord); err != nil {
            log.Error("更新提现申请状态失败", zap.Error(err))
        }
    }
    
    callbackLog.Processed = 1
    callbackLog.ProcessResult = "处理成功"
    
    return nil
}

type TransferRequest struct {
    WithdrawRequestID uint64  `json:"withdraw_request_id"`
    UserID           uint64  `json:"user_id"`
    OpenID           string  `json:"openid"`
    Amount           float64 `json:"amount"`
    Description      string  `json:"description"`
    ClientIP         string  `json:"client_ip"`
}

type TransferResponse struct {
    PartnerTradeNo string `json:"partner_trade_no"`
    PaymentNo      string `json:"payment_no"`
    Success        bool   `json:"success"`
    Message        string `json:"message"`
}

type TransferQueryResponse struct {
    PartnerTradeNo string    `json:"partner_trade_no"`
    Status         string    `json:"status"`
    PaymentTime    time.Time `json:"payment_time"`
    Reason         string    `json:"reason"`
}
```

#### 4.3.6 模块六：门店服务模块
**功能：** 门店管理、门店商品管理、桌码管理
**实现步骤：**
1. 门店表结构设计
   ```sql
   CREATE TABLE stores (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       name VARCHAR(100),
       address VARCHAR(300),
       phone VARCHAR(20),
       latitude DECIMAL(10,7),
       longitude DECIMAL(10,7),
       business_hours VARCHAR(200),
       images TEXT,
       status TINYINT,
       created_at TIMESTAMP
   );
   ```
2. 门店CRUD接口实现
3. 门店距离计算接口
4. 门店商品管理接口
5. 桌码生成和管理
6. 门店订单管理接口

#### 4.3.7 模块七：营销服务模块
**功能：** 优惠券管理、活动管理、广告管理
**实现步骤：**
1. 营销相关表结构设计
2. 优惠券发放和使用逻辑
3. 营销活动管理接口
4. 轮播图广告管理
5. 积分系统实现
6. 会员权益配置

#### 4.3.8 模块八：分销服务模块
**功能：** 佣金计算、佣金结算、推广关系管理、提现处理
**实现步骤：**
1. 分销相关表结构设计
   ```sql
   -- 佣金记录表
   CREATE TABLE commission_records (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       user_id BIGINT,
       order_id BIGINT,
       commission_amount DECIMAL(10,2),
       commission_type TINYINT,
       status TINYINT,
       created_at TIMESTAMP
   );
   ```
2. 佣金计算逻辑实现
3. 佣金结算接口
4. 推广数据统计
5. 提现申请完整流程处理
6. 分销规则配置

**提现申请处理流程：**
```go
// 提现服务
type WithdrawService struct {
    db              *gorm.DB
    transferService TransferService
    userService     UserService
}

// 提现申请流程
func (s *WithdrawService) ProcessWithdrawRequest(ctx context.Context, requestID uint64, operatorID uint64) error {
    // 1. 查询提现申请
    withdrawReq, err := s.getWithdrawRequest(ctx, requestID)
    if err != nil {
        return fmt.Errorf("查询提现申请失败: %v", err)
    }
    
    // 2. 状态校验
    if withdrawReq.Status != 2 { // 2-已通过
        return fmt.Errorf("提现申请状态不正确，当前状态: %d", withdrawReq.Status)
    }
    
    // 3. 获取用户微信信息
    user, err := s.userService.GetUserByID(ctx, withdrawReq.UserID)
    if err != nil {
        return fmt.Errorf("获取用户信息失败: %v", err)
    }
    
    if user.WechatOpenid == "" {
        return fmt.Errorf("用户未绑定微信")
    }
    
    // 4. 更新提现申请状态为"打款中"
    if err := s.updateWithdrawStatus(ctx, requestID, 4, operatorID, "开始执行微信打款"); err != nil {
        return fmt.Errorf("更新提现状态失败: %v", err)
    }
    
    // 5. 调用微信企业付款
    transferReq := &TransferRequest{
        WithdrawRequestID: requestID,
        UserID:           withdrawReq.UserID,
        OpenID:           user.WechatOpenid,
        Amount:           withdrawReq.RealAmount,
        Description:      fmt.Sprintf("茶心阁佣金提现-%.2f元", withdrawReq.RealAmount),
        ClientIP:         "127.0.0.1", // 服务器IP
    }
    
    transferResp, err := s.transferService.TransferToWallet(ctx, transferReq)
    if err != nil {
        // 打款失败，更新状态
        s.updateWithdrawStatus(ctx, requestID, 6, operatorID, fmt.Sprintf("微信打款失败: %v", err))
        return fmt.Errorf("微信打款失败: %v", err)
    }
    
    // 6. 根据打款结果更新状态
    if transferResp.Success {
        // 打款成功
        if err := s.updateWithdrawStatus(ctx, requestID, 5, operatorID, "微信打款成功"); err != nil {
            log.Error("更新提现完成状态失败", zap.Error(err))
        }
        
        // 记录完成时间
        s.updateCompleteTime(ctx, requestID, time.Now())
        
        log.Info("提现处理成功",
            zap.Uint64("request_id", requestID),
            zap.Uint64("user_id", withdrawReq.UserID),
            zap.Float64("amount", withdrawReq.RealAmount),
            zap.String("partner_trade_no", transferResp.PartnerTradeNo))
            
    } else {
        // 打款失败
        s.updateWithdrawStatus(ctx, requestID, 6, operatorID, fmt.Sprintf("微信打款失败: %s", transferResp.Message))
        return fmt.Errorf("微信打款失败: %s", transferResp.Message)
    }
    
    return nil
}

// 批量处理提现申请
func (s *WithdrawService) BatchProcessWithdraws(ctx context.Context, operatorID uint64) error {
    // 查询所有已通过审核的提现申请
    var withdrawRequests []WithdrawRequest
    err := s.db.WithContext(ctx).
        Where("status = ? AND withdraw_type = ? AND is_deleted = 0", 2, 2). // 2-已通过, 2-微信零钱
        Order("created_at ASC").
        Limit(50). // 每次最多处理50个
        Find(&withdrawRequests).Error
    
    if err != nil {
        return fmt.Errorf("查询待处理提现申请失败: %v", err)
    }
    
    log.Info("开始批量处理提现申请", zap.Int("count", len(withdrawRequests)))
    
    for _, req := range withdrawRequests {
        // 逐个处理，避免并发问题
        if err := s.ProcessWithdrawRequest(ctx, req.ID, operatorID); err != nil {
            log.Error("处理提现申请失败",
                zap.Uint64("request_id", req.ID),
                zap.Uint64("user_id", req.UserID),
                zap.Error(err))
            continue
        }
        
        // 间隔处理，避免频率限制
        time.Sleep(2 * time.Second)
    }
    
    return nil
}

// 定时任务：自动处理提现
func (s *WithdrawService) AutoProcessWithdraws() {
    ticker := time.NewTicker(10 * time.Minute) // 每10分钟检查一次
    defer ticker.Stop()
    
    for range ticker.C {
        ctx := context.Background()
        
        if err := s.BatchProcessWithdraws(ctx, 0); err != nil { // 0表示系统自动处理
            log.Error("自动处理提现失败", zap.Error(err))
        }
    }
}

// 提现状态更新
func (s *WithdrawService) updateWithdrawStatus(ctx context.Context, requestID uint64, status int, operatorID uint64, remark string) error {
    updates := map[string]interface{}{
        "status":     status,
        "updated_by": operatorID,
        "updated_at": time.Now(),
    }
    
    if status == 4 { // 打款中
        updates["transfer_time"] = time.Now()
        updates["transfer_user_id"] = operatorID
    }
    
    if remark != "" {
        // 追加备注信息
        var currentRemark string
        s.db.WithContext(ctx).Model(&WithdrawRequest{}).
            Where("id = ?", requestID).
            Pluck("audit_remark", &currentRemark)
            
        if currentRemark != "" {
            updates["audit_remark"] = currentRemark + "; " + remark
        } else {
            updates["audit_remark"] = remark
        }
    }
    
    return s.db.WithContext(ctx).
        Model(&WithdrawRequest{}).
        Where("id = ?", requestID).
        Updates(updates).Error
}

// 查询提现统计
func (s *WithdrawService) GetWithdrawStatistics(ctx context.Context, userID uint64) (*WithdrawStats, error) {
    stats := &WithdrawStats{}
    
    // 总提现金额
    s.db.WithContext(ctx).
        Model(&WithdrawRequest{}).
        Where("user_id = ? AND status = 5 AND is_deleted = 0", userID).
        Select("COALESCE(SUM(real_amount), 0)").
        Scan(&stats.TotalAmount)
    
    // 提现次数
    s.db.WithContext(ctx).
        Model(&WithdrawRequest{}).
        Where("user_id = ? AND status = 5 AND is_deleted = 0", userID).
        Count(&stats.TotalCount)
    
    // 本月提现金额
    currentMonth := time.Now().Format("2006-01")
    s.db.WithContext(ctx).
        Model(&WithdrawRequest{}).
        Where("user_id = ? AND status = 5 AND is_deleted = 0 AND DATE_FORMAT(complete_time, '%Y-%m') = ?", userID, currentMonth).
        Select("COALESCE(SUM(real_amount), 0)").
        Scan(&stats.MonthAmount)
    
    // 处理中金额
    s.db.WithContext(ctx).
        Model(&WithdrawRequest{}).
        Where("user_id = ? AND status IN (1,2,4) AND is_deleted = 0", userID).
        Select("COALESCE(SUM(real_amount), 0)").
        Scan(&stats.ProcessingAmount)
    
    return stats, nil
}

type WithdrawStats struct {
    TotalAmount     float64 `json:"total_amount"`     // 总提现金额
    TotalCount      int64   `json:"total_count"`      // 总提现次数
    MonthAmount     float64 `json:"month_amount"`     // 本月提现金额
    ProcessingAmount float64 `json:"processing_amount"` // 处理中金额
}
```

#### 4.3.9 模块九：消息服务模块
**功能：** 消息推送、短信发送、公众号集成
**实现步骤：**
1. 微信公众号SDK集成
2. 短信服务接入
3. 消息模板管理
4. 消息发送队列
5. 消息推送记录
6. 系统通知管理

#### 4.3.10 模块十：外卖对接模块
**功能：** 多平台外卖接口统一对接、订单同步、配送管理
**实现步骤：**
1. 外卖平台配置表设计
   ```sql
   -- 外卖平台配置表
   CREATE TABLE delivery_platforms (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '平台唯一标识',
       platform_name VARCHAR(50) NOT NULL COMMENT '平台名称',
       platform_code VARCHAR(20) NOT NULL COMMENT '平台编码：meituan, eleme, baidu',
       app_id VARCHAR(100) COMMENT '应用ID',
       app_secret VARCHAR(200) COMMENT '应用密钥',
       api_url VARCHAR(200) COMMENT 'API地址',
       webhook_url VARCHAR(200) COMMENT '回调地址',
       config_json TEXT COMMENT '平台特殊配置(JSON)',
       status TINYINT DEFAULT 1 COMMENT '状态：0停用 1启用',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       INDEX idx_uid (uid),
       INDEX idx_platform_code (platform_code),
       INDEX idx_is_deleted (is_deleted)
   );
   
   -- 门店外卖平台关联表
   CREATE TABLE store_delivery_platforms (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '关联唯一标识',
       store_id BIGINT NOT NULL COMMENT '门店ID',
       platform_id BIGINT NOT NULL COMMENT '外卖平台ID',
       platform_store_id VARCHAR(50) COMMENT '外卖平台门店ID',
       platform_store_name VARCHAR(100) COMMENT '外卖平台门店名称',
       sync_menu TINYINT DEFAULT 1 COMMENT '是否同步菜单：0否 1是',
       sync_order TINYINT DEFAULT 1 COMMENT '是否同步订单：0否 1是',
       status TINYINT DEFAULT 1 COMMENT '状态：0停用 1启用',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       UNIQUE KEY uk_store_platform (store_id, platform_id),
       INDEX idx_uid (uid),
       INDEX idx_store_id (store_id),
       INDEX idx_platform_id (platform_id),
       INDEX idx_is_deleted (is_deleted)
   );
   
   -- 外卖订单同步记录表
   CREATE TABLE delivery_order_sync (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '同步记录唯一标识',
       platform_id BIGINT NOT NULL COMMENT '外卖平台ID',
       store_id BIGINT NOT NULL COMMENT '门店ID',
       local_order_id BIGINT COMMENT '本地订单ID',
       platform_order_id VARCHAR(100) NOT NULL COMMENT '外卖平台订单ID',
       sync_type TINYINT NOT NULL COMMENT '同步类型：1推送到外卖平台 2从外卖平台拉取',
       sync_status TINYINT DEFAULT 1 COMMENT '同步状态：1同步中 2成功 3失败',
       request_data TEXT COMMENT '请求数据',
       response_data TEXT COMMENT '响应数据',
       error_message TEXT COMMENT '错误信息',
       retry_count INT DEFAULT 0 COMMENT '重试次数',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
       deleted_at TIMESTAMP NULL COMMENT '删除时间',
       INDEX idx_uid (uid),
       INDEX idx_platform_order_id (platform_order_id),
       INDEX idx_local_order_id (local_order_id),
       INDEX idx_is_deleted (is_deleted)
   );
   ```

2. 外卖平台接口抽象层设计
   ```go
   // 外卖平台接口
   type DeliveryPlatform interface {
       // 菜单同步
       SyncMenu(ctx context.Context, storeID string, products []Product) error
       
       // 创建订单
       CreateOrder(ctx context.Context, order *DeliveryOrder) (*DeliveryOrderResponse, error)
       
       // 取消订单
       CancelOrder(ctx context.Context, orderID string) error
       
       // 查询订单状态
       GetOrderStatus(ctx context.Context, orderID string) (*OrderStatus, error)
       
       // 处理回调
       HandleCallback(ctx context.Context, data []byte) (*CallbackResponse, error)
   }
   
   // 美团外卖实现
   type MeituanDelivery struct {
       config *DeliveryConfig
       client *http.Client
   }
   
   // 饿了么实现
   type ElemeDelivery struct {
       config *DeliveryConfig
       client *http.Client
   }
   
   // 百度外卖实现
   type BaiduDelivery struct {
       config *DeliveryConfig
       client *http.Client
   }
   ```

3. 统一外卖服务实现
4. 菜单同步功能（本地商品推送到外卖平台）
5. 订单双向同步（外卖平台订单拉取到本地）
6. 配送状态实时更新
7. 外卖平台回调处理
8. 错误重试机制和日志记录

#### 4.3.11 模块十一：访问日志模块
**功能：** 记录所有API访问请求、响应内容、用户行为追踪
**实现步骤：**
1. 访问日志表设计
   ```sql
   -- 访问日志表
   CREATE TABLE access_logs (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '日志唯一标识',
       trace_id VARCHAR(32) COMMENT '链路追踪ID',
       user_id BIGINT COMMENT '用户ID',
       session_id VARCHAR(64) COMMENT '会话ID',
       ip_address VARCHAR(45) COMMENT 'IP地址',
       user_agent TEXT COMMENT '用户代理',
       method VARCHAR(10) NOT NULL COMMENT 'HTTP方法',
       url TEXT NOT NULL COMMENT '请求URL',
       path VARCHAR(500) COMMENT '请求路径',
       query_params TEXT COMMENT '查询参数',
       request_headers TEXT COMMENT '请求头(JSON)',
       request_body TEXT COMMENT '请求体',
       response_status INT COMMENT '响应状态码',
       response_headers TEXT COMMENT '响应头(JSON)',
       response_body TEXT COMMENT '响应体',
       response_size INT COMMENT '响应大小(bytes)',
       duration_ms INT COMMENT '请求耗时(ms)',
       error_message TEXT COMMENT '错误信息',
       client_type TINYINT COMMENT '客户端类型：1小程序 2管理后台 3API',
       platform VARCHAR(20) COMMENT '平台：ios, android, web',
       app_version VARCHAR(20) COMMENT '应用版本',
       api_version VARCHAR(10) COMMENT 'API版本',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       INDEX idx_uid (uid),
       INDEX idx_user_id (user_id),
       INDEX idx_ip_address (ip_address),
       INDEX idx_created_at (created_at),
       INDEX idx_trace_id (trace_id)
   ) ENGINE=InnoDB PARTITION BY RANGE (TO_DAYS(created_at)) (
       PARTITION p202411 VALUES LESS THAN (TO_DAYS('2024-12-01')),
       PARTITION p202412 VALUES LESS THAN (TO_DAYS('2025-01-01')),
       PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
       PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
       PARTITION p202503 VALUES LESS THAN (TO_DAYS('2025-04-01')),
       PARTITION pmax VALUES LESS THAN MAXVALUE
   );
   
   -- 访问统计表（按天汇总）
   CREATE TABLE access_statistics (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '统计唯一标识',
       stat_date DATE NOT NULL COMMENT '统计日期',
       total_requests INT DEFAULT 0 COMMENT '总请求数',
       unique_users INT DEFAULT 0 COMMENT '独立用户数',
       unique_ips INT DEFAULT 0 COMMENT '独立IP数',
       avg_response_time DECIMAL(8,2) DEFAULT 0 COMMENT '平均响应时间(ms)',
       error_count INT DEFAULT 0 COMMENT '错误请求数',
       error_rate DECIMAL(5,2) DEFAULT 0 COMMENT '错误率(%)',
       total_traffic BIGINT DEFAULT 0 COMMENT '总流量(bytes)',
       peak_hour TINYINT COMMENT '峰值小时',
       peak_requests INT DEFAULT 0 COMMENT '峰值请求数',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       UNIQUE KEY uk_stat_date (stat_date),
       INDEX idx_uid (uid)
   );
   
   -- 日志清理配置表
   CREATE TABLE log_cleanup_config (
       id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
       uid VARCHAR(32) UNIQUE NOT NULL COMMENT '配置唯一标识',
       table_name VARCHAR(50) NOT NULL COMMENT '表名',
       retention_days INT DEFAULT 30 COMMENT '保留天数',
       retention_count INT DEFAULT 1000000 COMMENT '保留条数',
       batch_size INT DEFAULT 500 COMMENT '每次删除条数',
       cleanup_hour TINYINT DEFAULT 2 COMMENT '清理时间(小时)',
       enabled TINYINT DEFAULT 1 COMMENT '是否启用：0否 1是',
       last_cleanup_at TIMESTAMP NULL COMMENT '上次清理时间',
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
       created_by BIGINT COMMENT '创建人ID',
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
       updated_by BIGINT COMMENT '修改人ID',
       INDEX idx_uid (uid),
       INDEX idx_table_name (table_name)
   );
   ```

2. 访问日志中间件增强
   ```go
   // 增强版访问日志中间件
   func EnhancedAccessLogMiddleware() gin.HandlerFunc {
       return func(c *gin.Context) {
           start := time.Now()
           traceID := generateTraceID()
           c.Header("X-Trace-ID", traceID)
           
           // 记录请求信息
           requestBody, _ := c.GetRawData()
           c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(requestBody))
           
           // 创建响应写入器来捕获响应
           writer := &responseWriter{
               ResponseWriter: c.Writer,
               body:          bytes.NewBuffer([]byte{}),
           }
           c.Writer = writer
           
           c.Next()
           
           // 记录访问日志
           duration := time.Since(start)
           logEntry := &AccessLog{
               UID:            generateLogUID(),
               TraceID:        traceID,
               UserID:         getUserID(c),
               SessionID:      getSessionID(c),
               IPAddress:      c.ClientIP(),
               UserAgent:      c.GetHeader("User-Agent"),
               Method:         c.Request.Method,
               URL:            c.Request.URL.String(),
               Path:           c.Request.URL.Path,
               QueryParams:    c.Request.URL.RawQuery,
               RequestHeaders: getHeadersJSON(c.Request.Header),
               RequestBody:    string(requestBody),
               ResponseStatus: c.Writer.Status(),
               ResponseHeaders: getHeadersJSON(c.Writer.Header()),
               ResponseBody:   writer.body.String(),
               ResponseSize:   writer.body.Len(),
               DurationMs:     int(duration.Milliseconds()),
               ClientType:     getClientType(c),
               Platform:      getPlatform(c),
               AppVersion:    c.GetHeader("App-Version"),
               APIVersion:    c.GetHeader("API-Version"),
           }
           
           // 异步写入日志
           go func() {
               if err := saveAccessLog(logEntry); err != nil {
                   log.Error("保存访问日志失败", zap.Error(err))
               }
           }()
       }
   }
   
   type responseWriter struct {
       gin.ResponseWriter
       body *bytes.Buffer
   }
   
   func (w *responseWriter) Write(b []byte) (int, error) {
       w.body.Write(b)
       return w.ResponseWriter.Write(b)
   }
   ```

3. 日志数据压缩和存储优化
4. 敏感信息过滤（密码、token等）
5. 日志查询和分析接口
6. 实时监控和告警机制

### 4.4 数据库设计

#### 4.4.1 标准字段定义
**每张表必须包含以下审计字段：**
```sql
-- 标准审计字段
id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
uid VARCHAR(32) UNIQUE NOT NULL COMMENT '业务唯一标识',
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
created_by BIGINT COMMENT '创建人ID',
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
updated_by BIGINT COMMENT '修改人ID',
is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
deleted_at TIMESTAMP NULL COMMENT '删除时间'
```

#### 4.4.2 核心表结构
```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '用户唯一标识',
    phone VARCHAR(11) UNIQUE COMMENT '手机号',
    wechat_openid VARCHAR(100) COMMENT '微信OpenID',
    nickname VARCHAR(50) COMMENT '昵称',
    avatar VARCHAR(200) COMMENT '头像',
    user_type TINYINT DEFAULT 0 COMMENT '用户类型：0普通用户 1会员 2合伙人 3门店管理员 4超级管理员',
    level TINYINT DEFAULT 0 COMMENT '等级',
    parent_id BIGINT COMMENT '推荐人ID',
    balance DECIMAL(10,2) DEFAULT 0 COMMENT '余额',
    tea_coin DECIMAL(10,2) DEFAULT 0 COMMENT '茶币',
    points INT DEFAULT 0 COMMENT '积分',
    status TINYINT DEFAULT 1 COMMENT '状态：0禁用 1启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_phone (phone),
    INDEX idx_parent_id (parent_id),
    INDEX idx_is_deleted (is_deleted)
);

-- 商品分类表
CREATE TABLE categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '分类唯一标识',
    name VARCHAR(50) NOT NULL COMMENT '分类名称',
    parent_id BIGINT DEFAULT 0 COMMENT '父分类ID',
    level TINYINT DEFAULT 1 COMMENT '层级',
    sort INT DEFAULT 0 COMMENT '排序',
    icon VARCHAR(200) COMMENT '图标',
    status TINYINT DEFAULT 1 COMMENT '状态：0禁用 1启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_parent_id (parent_id),
    INDEX idx_is_deleted (is_deleted)
);

-- 商品表
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '商品唯一标识',
    category_id BIGINT COMMENT '分类ID',
    name VARCHAR(200) NOT NULL COMMENT '商品名称',
    subtitle VARCHAR(300) COMMENT '副标题',
    main_image VARCHAR(500) COMMENT '主图',
    sub_images TEXT COMMENT '子图列表(JSON)',
    detail TEXT COMMENT '商品详情',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    original_price DECIMAL(10,2) COMMENT '原价',
    stock INT DEFAULT 0 COMMENT '库存',
    sales_count INT DEFAULT 0 COMMENT '销量',
    product_type TINYINT DEFAULT 1 COMMENT '商品类型：1商城 2门店服务 3积分商品',
    purpose TINYINT COMMENT '用途分类：1送礼 2收藏 3口粮 4散茶',
    origin VARCHAR(50) COMMENT '产地',
    package_type VARCHAR(50) COMMENT '包装类型',
    brand VARCHAR(100) COMMENT '品牌',
    weight DECIMAL(8,2) COMMENT '重量(g)',
    unit VARCHAR(20) DEFAULT '件' COMMENT '单位',
    status TINYINT DEFAULT 1 COMMENT '状态：0下架 1上架',
    sort INT DEFAULT 0 COMMENT '排序',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_category_id (category_id),
    INDEX idx_product_type (product_type),
    INDEX idx_is_deleted (is_deleted)
);

-- 门店表
CREATE TABLE stores (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '门店唯一标识',
    name VARCHAR(100) NOT NULL COMMENT '门店名称',
    address VARCHAR(300) COMMENT '地址',
    phone VARCHAR(20) COMMENT '联系电话',
    latitude DECIMAL(10,7) COMMENT '纬度',
    longitude DECIMAL(10,7) COMMENT '经度',
    business_hours VARCHAR(200) COMMENT '营业时间',
    images TEXT COMMENT '门店图片(JSON)',
    description TEXT COMMENT '门店介绍',
    license_images TEXT COMMENT '营业执照等证件(JSON)',
    admin_user_id BIGINT COMMENT '门店管理员ID',
    status TINYINT DEFAULT 1 COMMENT '状态：0停业 1营业',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_admin_user_id (admin_user_id),
    INDEX idx_is_deleted (is_deleted)
);

-- 订单表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '订单唯一标识',
    order_no VARCHAR(50) UNIQUE NOT NULL COMMENT '订单号',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    store_id BIGINT COMMENT '门店ID',
    order_type TINYINT NOT NULL COMMENT '订单类型：1商城 2堂食 3外卖 4积分商城',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '订单总额',
    discount_amount DECIMAL(10,2) DEFAULT 0 COMMENT '优惠金额',
    pay_amount DECIMAL(10,2) NOT NULL COMMENT '实付金额',
    pay_type TINYINT COMMENT '支付方式：1微信 2支付宝 3余额 4茶币',
    pay_status TINYINT DEFAULT 0 COMMENT '支付状态：0待支付 1已支付 2已退款',
    order_status TINYINT DEFAULT 1 COMMENT '订单状态：1待付款 2待发货 3待收货 4已完成 5已取消',
    shipping_address TEXT COMMENT '收货地址(JSON)',
    remark VARCHAR(500) COMMENT '订单备注',
    table_code VARCHAR(50) COMMENT '桌码(堂食订单)',
    delivery_fee DECIMAL(8,2) DEFAULT 0 COMMENT '配送费',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_order_no (order_no),
    INDEX idx_user_id (user_id),
    INDEX idx_store_id (store_id),
    INDEX idx_is_deleted (is_deleted)
);

-- 订单商品表
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '订单商品唯一标识',
    order_id BIGINT NOT NULL COMMENT '订单ID',
    product_id BIGINT NOT NULL COMMENT '商品ID',
    product_name VARCHAR(200) NOT NULL COMMENT '商品名称',
    product_image VARCHAR(500) COMMENT '商品图片',
    quantity INT NOT NULL COMMENT '数量',
    price DECIMAL(10,2) NOT NULL COMMENT '单价',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '小计',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id),
    INDEX idx_is_deleted (is_deleted)
);
```

### 4.5 API接口设计

#### 4.5.1 RESTful API 规范
```
GET    /api/v1/users        # 获取用户列表
GET    /api/v1/users/:id    # 获取用户详情
POST   /api/v1/users        # 创建用户
PUT    /api/v1/users/:id    # 更新用户
DELETE /api/v1/users/:id    # 删除用户
```

#### 4.4.3 其他核心表结构
```sql
-- 优惠券表
CREATE TABLE coupons (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '优惠券唯一标识',
    name VARCHAR(100) NOT NULL COMMENT '优惠券名称',
    type TINYINT NOT NULL COMMENT '类型：1满减 2折扣 3免运费',
    amount DECIMAL(10,2) COMMENT '优惠金额',
    discount DECIMAL(4,2) COMMENT '折扣比例',
    min_amount DECIMAL(10,2) DEFAULT 0 COMMENT '最低使用金额',
    total_count INT DEFAULT 0 COMMENT '发放总数',
    used_count INT DEFAULT 0 COMMENT '已使用数量',
    per_user_limit INT DEFAULT 1 COMMENT '每人限领数量',
    start_time TIMESTAMP COMMENT '开始时间',
    end_time TIMESTAMP COMMENT '结束时间',
    status TINYINT DEFAULT 1 COMMENT '状态：0停用 1启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_is_deleted (is_deleted)
);

-- 佣金记录表
CREATE TABLE commission_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '佣金记录唯一标识',
    user_id BIGINT NOT NULL COMMENT '获得佣金的用户ID',
    order_id BIGINT NOT NULL COMMENT '订单ID',
    order_user_id BIGINT NOT NULL COMMENT '下单用户ID',
    commission_type TINYINT NOT NULL COMMENT '佣金类型：1直推佣金 2团队奖励',
    commission_amount DECIMAL(10,2) NOT NULL COMMENT '佣金金额',
    commission_rate DECIMAL(4,2) COMMENT '佣金比例',
    order_amount DECIMAL(10,2) COMMENT '订单金额',
    status TINYINT DEFAULT 1 COMMENT '状态：1待结算 2已结算 3已取消',
    settle_time TIMESTAMP NULL COMMENT '结算时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_user_id (user_id),
    INDEX idx_order_id (order_id),
    INDEX idx_is_deleted (is_deleted)
);

-- 提现申请表
CREATE TABLE withdraw_requests (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '提现申请唯一标识',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    amount DECIMAL(10,2) NOT NULL COMMENT '提现金额',
    fee DECIMAL(10,2) DEFAULT 0 COMMENT '手续费',
    real_amount DECIMAL(10,2) NOT NULL COMMENT '实际到账金额',
    withdraw_type TINYINT DEFAULT 1 COMMENT '提现方式：1银行卡 2微信零钱 3支付宝',
    account_info TEXT COMMENT '收款账户信息(JSON)',
    status TINYINT DEFAULT 1 COMMENT '状态：1申请中 2已通过 3已拒绝 4打款中 5已完成 6打款失败',
    audit_time TIMESTAMP NULL COMMENT '审核时间',
    audit_user_id BIGINT COMMENT '审核人ID',
    audit_remark VARCHAR(500) COMMENT '审核备注',
    transfer_time TIMESTAMP NULL COMMENT '打款时间',
    transfer_user_id BIGINT COMMENT '打款操作人ID',
    complete_time TIMESTAMP NULL COMMENT '完成时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_is_deleted (is_deleted)
);

-- 微信打款记录表
CREATE TABLE wechat_transfer_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '打款记录唯一标识',
    withdraw_request_id BIGINT NOT NULL COMMENT '提现申请ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    wechat_openid VARCHAR(100) NOT NULL COMMENT '微信OpenID',
    partner_trade_no VARCHAR(50) UNIQUE NOT NULL COMMENT '商户订单号',
    amount DECIMAL(10,2) NOT NULL COMMENT '打款金额(分)',
    desc_text VARCHAR(100) COMMENT '打款描述',
    spbill_create_ip VARCHAR(45) COMMENT '发起IP',
    transfer_status TINYINT DEFAULT 1 COMMENT '打款状态：1处理中 2成功 3失败',
    wechat_order_id VARCHAR(50) COMMENT '微信订单号',
    payment_no VARCHAR(50) COMMENT '微信支付单号',
    payment_time TIMESTAMP NULL COMMENT '微信到账时间',
    reason VARCHAR(200) COMMENT '失败原因',
    request_data TEXT COMMENT '请求数据(JSON)',
    response_data TEXT COMMENT '响应数据(JSON)',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_withdraw_request_id (withdraw_request_id),
    INDEX idx_partner_trade_no (partner_trade_no),
    INDEX idx_wechat_openid (wechat_openid),
    INDEX idx_transfer_status (transfer_status),
    INDEX idx_is_deleted (is_deleted)
);

-- 打款回调记录表
CREATE TABLE transfer_callback_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '回调记录唯一标识',
    transfer_record_id BIGINT NOT NULL COMMENT '打款记录ID',
    callback_type TINYINT NOT NULL COMMENT '回调类型：1微信 2支付宝',
    callback_data TEXT COMMENT '回调原始数据',
    processed TINYINT DEFAULT 0 COMMENT '是否已处理：0否 1是',
    process_result TEXT COMMENT '处理结果',
    error_message TEXT COMMENT '错误信息',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_uid (uid),
    INDEX idx_transfer_record_id (transfer_record_id),
    INDEX idx_processed (processed)
);

-- 系统配置表
CREATE TABLE system_configs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    uid VARCHAR(32) UNIQUE NOT NULL COMMENT '配置唯一标识',
    config_key VARCHAR(100) UNIQUE NOT NULL COMMENT '配置键',
    config_value TEXT COMMENT '配置值',
    config_type TINYINT DEFAULT 1 COMMENT '配置类型：1字符串 2数字 3布尔 4JSON',
    description VARCHAR(200) COMMENT '配置描述',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    created_by BIGINT COMMENT '创建人ID',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    updated_by BIGINT COMMENT '修改人ID',
    is_deleted TINYINT DEFAULT 0 COMMENT '是否删除：0否 1是',
    deleted_at TIMESTAMP NULL COMMENT '删除时间',
    INDEX idx_uid (uid),
    INDEX idx_config_key (config_key),
    INDEX idx_is_deleted (is_deleted)
);
```

#### 4.4.4 GORM模型设计
```go
// 基础模型结构
type BaseModel struct {
    ID        uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
    UID       string    `gorm:"type:varchar(32);uniqueIndex;not null" json:"uid"`
    CreatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
    CreatedBy uint64    `gorm:"index" json:"created_by"`
    UpdatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"`
    UpdatedBy uint64    `gorm:"index" json:"updated_by"`
    IsDeleted int8      `gorm:"default:0;index" json:"is_deleted"`
    DeletedAt *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}

// 用户模型
type User struct {
    BaseModel
    Phone       string          `gorm:"type:varchar(11);uniqueIndex" json:"phone"`
    WechatOpenid string         `gorm:"type:varchar(100)" json:"wechat_openid"`
    Nickname    string          `gorm:"type:varchar(50)" json:"nickname"`
    Avatar      string          `gorm:"type:varchar(200)" json:"avatar"`
    UserType    int8            `gorm:"default:0" json:"user_type"`
    Level       int8            `gorm:"default:0" json:"level"`
    ParentID    uint64          `gorm:"index" json:"parent_id"`
    Balance     decimal.Decimal `gorm:"type:decimal(10,2);default:0" json:"balance"`
    TeaCoin     decimal.Decimal `gorm:"type:decimal(10,2);default:0" json:"tea_coin"`
    Points      int32           `gorm:"default:0" json:"points"`
    Status      int8            `gorm:"default:1" json:"status"`
}

// 自定义表名
func (User) TableName() string {
    return "users"
}

// 软删除查询作用域
func (u *User) BeforeFind(tx *gorm.DB) error {
    return tx.Where("is_deleted = 0").Error
}

// 商品模型
type Product struct {
    BaseModel
    CategoryID   uint64          `gorm:"index" json:"category_id"`
    Name         string          `gorm:"type:varchar(200);not null" json:"name"`
    Subtitle     string          `gorm:"type:varchar(300)" json:"subtitle"`
    MainImage    string          `gorm:"type:varchar(500)" json:"main_image"`
    SubImages    string          `gorm:"type:text" json:"sub_images"`
    Detail       string          `gorm:"type:text" json:"detail"`
    Price        decimal.Decimal `gorm:"type:decimal(10,2);not null" json:"price"`
    OriginalPrice decimal.Decimal `gorm:"type:decimal(10,2)" json:"original_price"`
    Stock        int32           `gorm:"default:0" json:"stock"`
    SalesCount   int32           `gorm:"default:0" json:"sales_count"`
    ProductType  int8            `gorm:"default:1;index" json:"product_type"`
    Purpose      int8            `json:"purpose"`
    Origin       string          `gorm:"type:varchar(50)" json:"origin"`
    PackageType  string          `gorm:"type:varchar(50)" json:"package_type"`
    Brand        string          `gorm:"type:varchar(100)" json:"brand"`
    Weight       decimal.Decimal `gorm:"type:decimal(8,2)" json:"weight"`
    Unit         string          `gorm:"type:varchar(20);default:'件'" json:"unit"`
    Status       int8            `gorm:"default:1" json:"status"`
    Sort         int32           `gorm:"default:0" json:"sort"`
}

func (Product) TableName() string {
    return "products"
}

// 提现申请模型
type WithdrawRequest struct {
    BaseModel
    UserID         uint64          `gorm:"not null;index" json:"user_id"`
    Amount         decimal.Decimal `gorm:"type:decimal(10,2);not null" json:"amount"`
    Fee            decimal.Decimal `gorm:"type:decimal(10,2);default:0" json:"fee"`
    RealAmount     decimal.Decimal `gorm:"type:decimal(10,2);not null" json:"real_amount"`
    WithdrawType   int8            `gorm:"default:1" json:"withdraw_type"` // 1银行卡 2微信零钱 3支付宝
    AccountInfo    string          `gorm:"type:text" json:"account_info"`
    Status         int8            `gorm:"default:1;index" json:"status"` // 1申请中 2已通过 3已拒绝 4打款中 5已完成 6打款失败
    AuditTime      *time.Time      `json:"audit_time,omitempty"`
    AuditUserID    uint64          `json:"audit_user_id"`
    AuditRemark    string          `gorm:"type:varchar(500)" json:"audit_remark"`
    TransferTime   *time.Time      `json:"transfer_time,omitempty"`
    TransferUserID uint64          `json:"transfer_user_id"`
    CompleteTime   *time.Time      `json:"complete_time,omitempty"`
}

func (WithdrawRequest) TableName() string {
    return "withdraw_requests"
}

// 微信打款记录模型
type WechatTransferRecord struct {
    BaseModel
    WithdrawRequestID uint64          `gorm:"not null;index" json:"withdraw_request_id"`
    UserID           uint64          `gorm:"not null;index" json:"user_id"`
    WechatOpenID     string          `gorm:"type:varchar(100);not null;index" json:"wechat_openid"`
    PartnerTradeNo   string          `gorm:"type:varchar(50);unique;not null;index" json:"partner_trade_no"`
    Amount           decimal.Decimal `gorm:"type:decimal(10,2);not null" json:"amount"`
    DescText         string          `gorm:"type:varchar(100)" json:"desc_text"`
    SpbillCreateIP   string          `gorm:"type:varchar(45)" json:"spbill_create_ip"`
    TransferStatus   int8            `gorm:"default:1;index" json:"transfer_status"` // 1处理中 2成功 3失败
    WechatOrderID    string          `gorm:"type:varchar(50)" json:"wechat_order_id"`
    PaymentNo        string          `gorm:"type:varchar(50)" json:"payment_no"`
    PaymentTime      *time.Time      `json:"payment_time,omitempty"`
    Reason           string          `gorm:"type:varchar(200)" json:"reason"`
    RequestData      string          `gorm:"type:text" json:"request_data"`
    ResponseData     string          `gorm:"type:text" json:"response_data"`
    RetryCount       int32           `gorm:"default:0" json:"retry_count"`
}

func (WechatTransferRecord) TableName() string {
    return "wechat_transfer_records"
}

// 打款回调日志模型
type TransferCallbackLog struct {
    BaseModel
    TransferRecordID uint64 `gorm:"not null;index" json:"transfer_record_id"`
    CallbackType     int8   `gorm:"not null" json:"callback_type"` // 1微信 2支付宝
    CallbackData     string `gorm:"type:text" json:"callback_data"`
    Processed        int8   `gorm:"default:0;index" json:"processed"` // 0否 1是
    ProcessResult    string `gorm:"type:text" json:"process_result"`
    ErrorMessage     string `gorm:"type:text" json:"error_message"`
}

func (TransferCallbackLog) TableName() string {
    return "transfer_callback_logs"
}
```

#### 4.4.5 软删除实现
```go
// 软删除中间件
func SoftDeleteScope(db *gorm.DB) *gorm.DB {
    return db.Where("is_deleted = 0")
}

// 全局软删除配置
func InitDB() *gorm.DB {
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic("failed to connect database")
    }
    
    // 注册全局软删除作用域
    db.Callback().Query().Before("gorm:query").Register("soft_delete", func(db *gorm.DB) {
        if db.Statement.Schema != nil {
            if field := db.Statement.Schema.LookUpField("IsDeleted"); field != nil {
                db.Where("is_deleted = 0")
            }
        }
    })
    
    return db
}

// 软删除操作
func SoftDelete(db *gorm.DB, model interface{}, id uint64, operatorID uint64) error {
    return db.Model(model).Where("id = ?", id).Updates(map[string]interface{}{
        "is_deleted": 1,
        "deleted_at": time.Now(),
        "updated_by": operatorID,
    }).Error
}
```

#### 4.5.2 核心接口列表
```
# 用户相关
POST   /api/v1/auth/login           # 登录
POST   /api/v1/auth/register        # 注册
GET    /api/v1/user/profile         # 获取用户信息
PUT    /api/v1/user/profile         # 更新用户信息

# 商品相关
GET    /api/v1/products             # 获取商品列表
GET    /api/v1/products/:id         # 获取商品详情
GET    /api/v1/categories           # 获取分类列表

# 订单相关
POST   /api/v1/orders               # 创建订单
GET    /api/v1/orders               # 获取订单列表
GET    /api/v1/orders/:id           # 获取订单详情
PUT    /api/v1/orders/:id/cancel    # 取消订单

# 门店相关
GET    /api/v1/stores               # 获取门店列表
GET    /api/v1/stores/:id           # 获取门店详情
GET    /api/v1/stores/:id/products  # 获取门店商品

# 支付相关
POST   /api/v1/payments             # 发起支付
POST   /api/v1/payments/notify      # 支付回调

# 分销相关
GET    /api/v1/distribution/stats   # 分销统计
POST   /api/v1/distribution/bind    # 绑定推广关系
GET    /api/v1/commission/records   # 佣金记录

# 外卖对接相关
POST   /api/v1/delivery/platforms   # 添加外卖平台配置
GET    /api/v1/delivery/platforms   # 获取外卖平台列表
PUT    /api/v1/delivery/platforms/:id # 更新外卖平台配置
POST   /api/v1/delivery/sync/menu   # 同步菜单到外卖平台
POST   /api/v1/delivery/sync/order  # 同步订单到外卖平台
POST   /api/v1/delivery/callback    # 外卖平台回调接口
GET    /api/v1/delivery/orders      # 获取外卖订单列表
GET    /api/v1/delivery/sync/logs   # 获取同步日志

# 访问日志相关
GET    /api/v1/logs/access          # 获取访问日志
GET    /api/v1/logs/statistics      # 获取访问统计
POST   /api/v1/logs/cleanup/config  # 配置日志清理规则
GET    /api/v1/logs/cleanup/status  # 获取清理状态

# 提现和打款相关
POST   /api/v1/withdraw/apply       # 申请提现
GET    /api/v1/withdraw/requests    # 获取提现申请列表
GET    /api/v1/withdraw/requests/:id # 获取提现申请详情
PUT    /api/v1/withdraw/audit/:id   # 审核提现申请
POST   /api/v1/withdraw/process/:id # 处理提现申请(执行打款)
POST   /api/v1/withdraw/batch/process # 批量处理提现申请
GET    /api/v1/withdraw/statistics  # 获取提现统计
GET    /api/v1/transfer/records     # 获取打款记录
GET    /api/v1/transfer/query/:trade_no # 查询打款状态
POST   /api/v1/transfer/callback    # 微信打款回调接口
```

### 4.7 外卖平台API实现示例

#### 4.7.1 美团外卖API实现
```go
// 美团外卖服务实现
type MeituanDeliveryService struct {
    config *MeituanConfig
    client *http.Client
}

type MeituanConfig struct {
    AppID     string `json:"app_id"`
    AppSecret string `json:"app_secret"`
    BaseURL   string `json:"base_url"`
}

// 同步菜单到美团
func (s *MeituanDeliveryService) SyncMenu(ctx context.Context, storeID string, products []Product) error {
    // 构建美团菜单格式
    menuData := s.buildMeituanMenu(products)
    
    // 生成签名
    signature := s.generateSignature(menuData)
    
    // 发送请求
    url := fmt.Sprintf("%s/api/v1/menu/sync", s.config.BaseURL)
    req := &MeituanMenuSyncRequest{
        AppID:     s.config.AppID,
        StoreID:   storeID,
        MenuData:  menuData,
        Timestamp: time.Now().Unix(),
        Signature: signature,
    }
    
    resp, err := s.client.Post(url, "application/json", toJSON(req))
    if err != nil {
        return fmt.Errorf("美团菜单同步请求失败: %v", err)
    }
    defer resp.Body.Close()
    
    var result MeituanResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return fmt.Errorf("解析美团响应失败: %v", err)
    }
    
    if result.Code != 0 {
        return fmt.Errorf("美团菜单同步失败: %s", result.Message)
    }
    
    return nil
}

// 创建外卖订单
func (s *MeituanDeliveryService) CreateOrder(ctx context.Context, order *DeliveryOrder) (*DeliveryOrderResponse, error) {
    req := &MeituanCreateOrderRequest{
        AppID:       s.config.AppID,
        StoreID:     order.StoreID,
        OrderData:   s.convertToMeituanOrder(order),
        Timestamp:   time.Now().Unix(),
    }
    req.Signature = s.generateSignature(req)
    
    url := fmt.Sprintf("%s/api/v1/order/create", s.config.BaseURL)
    resp, err := s.client.Post(url, "application/json", toJSON(req))
    if err != nil {
        return nil, fmt.Errorf("美团订单创建失败: %v", err)
    }
    defer resp.Body.Close()
    
    var result MeituanOrderResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    return &DeliveryOrderResponse{
        PlatformOrderID: result.Data.OrderID,
        Status:          result.Data.Status,
        Message:         result.Message,
    }, nil
}

// 处理美团回调
func (s *MeituanDeliveryService) HandleCallback(ctx context.Context, data []byte) (*CallbackResponse, error) {
    var callback MeituanCallback
    if err := json.Unmarshal(data, &callback); err != nil {
        return nil, fmt.Errorf("解析美团回调数据失败: %v", err)
    }
    
    // 验证签名
    if !s.verifySignature(callback) {
        return nil, fmt.Errorf("美团回调签名验证失败")
    }
    
    // 处理不同类型的回调
    switch callback.Type {
    case "order_status_change":
        return s.handleOrderStatusChange(ctx, &callback)
    case "delivery_status_change":
        return s.handleDeliveryStatusChange(ctx, &callback)
    default:
        return &CallbackResponse{Success: true}, nil
    }
}
```

#### 4.7.2 饿了么API实现
```go
// 饿了么服务实现
type ElemeDeliveryService struct {
    config *ElemeConfig
    client *http.Client
}

type ElemeConfig struct {
    AppKey    string `json:"app_key"`
    AppSecret string `json:"app_secret"`
    BaseURL   string `json:"base_url"`
}

// 同步菜单到饿了么
func (s *ElemeDeliveryService) SyncMenu(ctx context.Context, storeID string, products []Product) error {
    // 获取访问令牌
    token, err := s.getAccessToken()
    if err != nil {
        return fmt.Errorf("获取饿了么访问令牌失败: %v", err)
    }
    
    // 构建饿了么菜单格式
    categories := s.buildElemeMenu(products)
    
    // 批量上传商品
    for _, category := range categories {
        if err := s.uploadCategory(token, storeID, category); err != nil {
            return fmt.Errorf("上传饿了么商品分类失败: %v", err)
        }
        
        for _, item := range category.Items {
            if err := s.uploadItem(token, storeID, item); err != nil {
                return fmt.Errorf("上传饿了么商品失败: %v", err)
            }
        }
    }
    
    return nil
}

// 获取饿了么访问令牌
func (s *ElemeDeliveryService) getAccessToken() (string, error) {
    url := fmt.Sprintf("%s/token", s.config.BaseURL)
    data := map[string]string{
        "grant_type": "client_credentials",
        "app_key":    s.config.AppKey,
        "app_secret": s.config.AppSecret,
    }
    
    resp, err := s.client.PostForm(url, toFormData(data))
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    var result struct {
        AccessToken string `json:"access_token"`
        ExpiresIn   int    `json:"expires_in"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return "", err
    }
    
    return result.AccessToken, nil
}
```

#### 4.7.3 统一外卖服务管理
```go
// 外卖服务管理器
type DeliveryManager struct {
    platforms map[string]DeliveryPlatform
    db        *gorm.DB
}

func NewDeliveryManager(db *gorm.DB) *DeliveryManager {
    return &DeliveryManager{
        platforms: make(map[string]DeliveryPlatform),
        db:        db,
    }
}

// 注册外卖平台
func (m *DeliveryManager) RegisterPlatform(code string, platform DeliveryPlatform) {
    m.platforms[code] = platform
}

// 同步所有平台菜单
func (m *DeliveryManager) SyncAllPlatforms(ctx context.Context, storeID uint64) error {
    // 获取门店关联的外卖平台
    var relations []StoreDeliveryPlatform
    if err := m.db.WithContext(ctx).
        Where("store_id = ? AND status = 1 AND sync_menu = 1", storeID).
        Find(&relations).Error; err != nil {
        return err
    }
    
    // 获取门店商品
    var products []Product
    if err := m.db.WithContext(ctx).
        Where("store_id = ? AND status = 1", storeID).
        Find(&products).Error; err != nil {
        return err
    }
    
    // 并发同步到各平台
    var wg sync.WaitGroup
    for _, relation := range relations {
        wg.Add(1)
        go func(rel StoreDeliveryPlatform) {
            defer wg.Done()
            
            platform, exists := m.platforms[rel.Platform.PlatformCode]
            if !exists {
                log.Error("未找到外卖平台实现", 
                    zap.String("platform_code", rel.Platform.PlatformCode))
                return
            }
            
            if err := platform.SyncMenu(ctx, rel.PlatformStoreID, products); err != nil {
                log.Error("同步菜单失败",
                    zap.String("platform", rel.Platform.PlatformName),
                    zap.String("store_id", rel.PlatformStoreID),
                    zap.Error(err))
                
                // 记录同步失败日志
                m.recordSyncLog(ctx, &DeliveryOrderSync{
                    PlatformID:      rel.PlatformID,
                    StoreID:         storeID,
                    SyncType:        1, // 菜单同步
                    SyncStatus:      3, // 失败
                    ErrorMessage:    err.Error(),
                })
            } else {
                log.Info("菜单同步成功",
                    zap.String("platform", rel.Platform.PlatformName),
                    zap.String("store_id", rel.PlatformStoreID))
            }
        }(relation)
    }
    
    wg.Wait()
    return nil
}

// 处理统一回调
func (m *DeliveryManager) HandleCallback(ctx context.Context, platformCode string, data []byte) error {
    platform, exists := m.platforms[platformCode]
    if !exists {
        return fmt.Errorf("未找到外卖平台: %s", platformCode)
    }
    
    response, err := platform.HandleCallback(ctx, data)
    if err != nil {
        log.Error("处理外卖平台回调失败",
            zap.String("platform", platformCode),
            zap.Error(err))
        return err
    }
    
    log.Info("外卖平台回调处理成功",
        zap.String("platform", platformCode),
        zap.Any("response", response))
    
    return nil
}
```

### 4.6 开发时间规划（单体应用架构）
- **第1-2周：** 项目架构搭建、数据库设计、基础框架搭建
  - 项目目录结构初始化
  - 数据库表结构设计和创建
  - GORM模型定义
  - 基础中间件（认证、日志、错误处理等）
  - 软删除机制实现
  - 访问日志中间件实现
  
- **第3-4周：** 用户模块、权限系统
  - 用户注册登录功能
  - JWT认证机制
  - RBAC权限系统
  - 微信登录集成
  
- **第5-6周：** 商品模块、门店模块
  - 商品CRUD操作
  - 分类管理
  - 门店管理
  - 图片上传处理
  
- **第7-8周：** 订单模块、支付模块
  - 订单创建流程
  - 订单状态管理
  - 微信支付集成
  - 支付回调处理
  
- **第9-10周：** 营销模块、分销模块
  - 优惠券系统
  - 佣金计算逻辑
  - 提现功能
  - 推广关系管理
  
- **第11-12周：** 外卖对接模块、消息模块
  - 美团外卖API对接
  - 饿了么外卖API对接
  - 百度外卖API对接
  - 外卖订单双向同步
  - 微信公众号集成
  - 短信发送功能
  
- **第13-14周：** 日志清理系统、系统集成
  - 独立日志清理服务开发
  - 访问日志统计分析
  - 系统配置管理
  - 接口文档完善
  
- **第15-16周：** 测试优化、部署上线
  - 单元测试编写
  - 外卖接口联调测试
  - 性能优化和压力测试
  - 安全测试
  - 生产环境部署

---

## 五、项目整体开发计划

### 5.1 开发阶段规划

#### 第一阶段：基础搭建（1-4周）
- 确定技术选型和架构设计
- 搭建开发环境和CI/CD流程
- 实现用户认证系统
- 完成基础页面和组件

#### 第二阶段：核心功能（5-10周）
- 商品管理系统
- 订单处理流程
- 支付集成
- 门店服务功能

#### 第三阶段：高级功能（11-14周）
- 分销系统实现
- 营销活动管理
- 数据统计分析
- 系统优化

#### 第四阶段：测试上线（15-16周）
- 系统集成测试
- 性能优化
- 安全测试
- 部署上线

### 5.2 团队配置建议
- **项目经理：** 1人
- **后端开发：** 2-3人
- **小程序开发：** 2人
- **前端开发：** 2人
- **UI设计师：** 1人
- **测试工程师：** 1人

### 5.3 风险评估与应对
1. **技术风险：** 微信支付集成、分销佣金计算复杂度
2. **进度风险：** 功能需求复杂，开发周期紧张
3. **质量风险：** 多端数据一致性、并发处理

### 5.4 交付物清单
- 微信小程序代码
- 管理后台代码
- 后端API服务代码
- 数据库设计文档
- API接口文档
- 部署文档
- 用户使用手册

---

## 六、技术难点与解决方案

### 6.1 分销系统佣金计算
**难点：** 多层级佣金计算、实时结算
**解决方案：** 使用事件驱动架构，异步计算佣金

### 6.2 多门店库存同步
**难点：** 实时库存更新、并发控制
**解决方案：** Redis分布式锁 + 消息队列

### 6.3 支付安全
**难点：** 支付数据安全、防重复支付
**解决方案：** 幂等性控制 + 签名验证

### 6.4 数据一致性
**难点：** 分布式事务处理
**解决方案：** TCC模式或Saga模式

### 6.5 权限管理系统设计
**权限模式：** RBAC（Role-Based Access Control）+ 层级数据权限

#### 6.5.1 角色定义
```go
// 用户角色枚举（含编号说明，供前后端统一）
const (
    RoleUser        = 0  // 普通用户
    RoleMember      = 1  // 会员
    RoleStaff       = 2  // 店员
    RolePartner     = 3  // 合伙人
    RoleStoreAdmin  = 4  // 门店管理员
    RoleSuperAdmin  = 5  // 超级管理员
)

// 权限类型
const (
    PermissionMenu   = 1  // 菜单权限
    PermissionButton = 2  // 按钮权限
    PermissionAPI    = 3  // API接口权限
)
```

#### 6.5.2 权限资源设计
**菜单权限：**
- 商品管理：商品列表、商品新增、商品编辑、商品删除
- 订单管理：订单查看、订单处理、订单统计
- 门店管理：门店信息、门店商品、桌码管理
- 用户管理：用户列表、会员管理、合伙人管理
- 营销管理：广告管理、优惠券管理、活动管理
- 财务管理：财务统计、佣金结算、提现管理

**数据权限：**
- 全局数据权限：超级管理员可查看所有数据
- 门店数据权限：门店管理员只能查看所属门店数据
- 个人数据权限：普通用户只能查看个人相关数据

#### 6.5.3 权限验证流程
```go
// 权限验证中间件伪代码
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 解析JWT Token
        token := c.GetHeader("Authorization")
        claims, err := jwt.ParseToken(token)
        if err != nil {
            c.JSON(401, "未授权访问")
            return
        }
        
        // 2. 获取用户权限（优先从Redis缓存获取）
        userID := claims.UserID
        permissions := getUserPermissions(userID)
        
        // 3. 验证API权限
        path := c.Request.URL.Path
        method := c.Request.Method
        if !hasPermission(permissions, path, method) {
            c.JSON(403, "无权限访问")
            return
        }
        
        // 4. 设置用户上下文
        c.Set("userID", userID)
        c.Set("userType", claims.UserType)
        c.Set("permissions", permissions)
        
        c.Next()
    }
}

// 数据权限过滤
func DataPermissionFilter(userID, userType int, query *gorm.DB) *gorm.DB {
    switch userType {
    case RoleStoreAdmin:
        // 门店管理员只能查看所属门店数据
        storeID := getUserStoreID(userID)
        return query.Where("store_id = ?", storeID)
    case RoleStaff:
        // 店员只能查看所属门店数据
        storeID := getUserStoreID(userID)
        return query.Where("store_id = ?", storeID)
    case RoleUser, RoleMember, RolePartner:
        // 普通用户只能查看个人数据
        return query.Where("user_id = ?", userID)
    default:
        // 超级管理员可查看所有数据
        return query
    }
}
```

#### 6.5.4 前端权限控制
**Vue.js 权限指令：**
```javascript
// 权限指令
app.directive('permission', {
  mounted(el, binding) {
    const { value } = binding
    const permissions = store.getters.permissions
    
    if (value && !permissions.includes(value)) {
      el.parentNode?.removeChild(el)
    }
  }
})

// 使用方式
<el-button v-permission="'product:delete'" @click="deleteProduct">删除</el-button>
```

**路由守卫：**
```javascript
router.beforeEach((to, from, next) => {
  const token = getToken()
  if (!token) {
    next('/login')
    return
  }
  
  // 检查路由权限
  const requiredPermission = to.meta.permission
  if (requiredPermission && !hasPermission(requiredPermission)) {
    next('/403')
    return
  }
  
  next()
})
```

#### 6.5.5 小程序权限控制
**页面访问控制：**
```javascript
// 页面onLoad时检查权限
onLoad() {
  const userType = wx.getStorageSync('userType')
  
  // 检查页面访问权限
  if (!this.checkPagePermission(userType)) {
    wx.showToast({
      title: '无访问权限',
      icon: 'none'
    })
    wx.navigateBack()
    return
  }
}

// 功能按钮权限控制
checkButtonPermission(action) {
  const userType = wx.getStorageSync('userType')
  const permissions = this.getUserPermissions(userType)
  return permissions.includes(action)
}
```

#### 6.5.6 缓存策略
- **Redis缓存：** 用户权限列表缓存30分钟
- **内存缓存：** 角色权限映射关系缓存1小时
- **更新机制：** 权限变更时主动清理对应缓存

这个权限管理系统采用RBAC模式，能够灵活支持茶心阁项目的复杂用户角色体系，确保系统安全性和数据隔离性。

### 6.6 日志清理系统设计

#### 6.6.1 独立日志清理服务
**服务名称：** log-cleaner-service
**功能：** 定期清理访问日志、操作日志等历史数据

**项目结构：**
```
log-cleaner/
├── cmd/
│   └── main.go              # 服务启动入口
├── internal/
│   ├── config/             # 配置管理
│   ├── cleaner/            # 清理逻辑
│   ├── scheduler/          # 调度器
│   └── monitor/            # 监控
├── pkg/
│   ├── database/           # 数据库连接
│   └── logger/             # 日志组件
└── configs/
    └── config.yaml         # 配置文件
```

#### 6.6.2 清理策略实现
```go
// 清理配置结构
type CleanupConfig struct {
    TableName      string `json:"table_name"`
    RetentionDays  int    `json:"retention_days"`
    RetentionCount int    `json:"retention_count"`
    BatchSize      int    `json:"batch_size"`
    CleanupHour    int    `json:"cleanup_hour"`
    Enabled        bool   `json:"enabled"`
}

// 清理服务接口
type CleanupService interface {
    // 按时间清理
    CleanupByTime(ctx context.Context, config *CleanupConfig) error
    // 按数量清理
    CleanupByCount(ctx context.Context, config *CleanupConfig) error
    // 获取清理统计
    GetCleanupStats(ctx context.Context, tableName string) (*CleanupStats, error)
}

// 清理服务实现
type cleanupService struct {
    db *gorm.DB
}

func NewCleanupService(db *gorm.DB) CleanupService {
    return &cleanupService{db: db}
}

// 按时间清理实现
func (s *cleanupService) CleanupByTime(ctx context.Context, config *CleanupConfig) error {
    cutoffTime := time.Now().AddDate(0, 0, -config.RetentionDays)
    
    for {
        var ids []uint64
        err := s.db.WithContext(ctx).
            Table(config.TableName).
            Where("created_at < ?", cutoffTime).
            Order("created_at ASC").
            Limit(config.BatchSize).
            Pluck("id", &ids)
        
        if err != nil {
            return fmt.Errorf("查询待删除记录失败: %v", err)
        }
        
        if len(ids) == 0 {
            break // 没有更多需要删除的记录
        }
        
        // 批量删除
        result := s.db.WithContext(ctx).
            Table(config.TableName).
            Where("id IN ?", ids).
            Delete(&struct{}{})
        
        if result.Error != nil {
            return fmt.Errorf("删除记录失败: %v", result.Error)
        }
        
        log.Info("清理日志记录",
            zap.String("table", config.TableName),
            zap.Int64("deleted_count", result.RowsAffected),
            zap.Time("cutoff_time", cutoffTime),
        )
        
        // 避免长时间占用数据库，间歇执行
        time.Sleep(100 * time.Millisecond)
    }
    
    return nil
}

// 按数量清理实现
func (s *cleanupService) CleanupByCount(ctx context.Context, config *CleanupConfig) error {
    var totalCount int64
    err := s.db.WithContext(ctx).
        Table(config.TableName).
        Count(&totalCount)
    
    if err != nil {
        return fmt.Errorf("统计记录总数失败: %v", err)
    }
    
    if totalCount <= int64(config.RetentionCount) {
        log.Info("记录数量未超限，无需清理",
            zap.String("table", config.TableName),
            zap.Int64("total_count", totalCount),
            zap.Int("retention_count", config.RetentionCount),
        )
        return nil
    }
    
    deleteCount := totalCount - int64(config.RetentionCount)
    deletedTotal := int64(0)
    
    for deletedTotal < deleteCount {
        batchSize := config.BatchSize
        if deleteCount-deletedTotal < int64(batchSize) {
            batchSize = int(deleteCount - deletedTotal)
        }
        
        var ids []uint64
        err := s.db.WithContext(ctx).
            Table(config.TableName).
            Order("created_at ASC").
            Limit(batchSize).
            Pluck("id", &ids)
        
        if err != nil {
            return fmt.Errorf("查询待删除记录失败: %v", err)
        }
        
        if len(ids) == 0 {
            break
        }
        
        result := s.db.WithContext(ctx).
            Table(config.TableName).
            Where("id IN ?", ids).
            Delete(&struct{}{})
        
        if result.Error != nil {
            return fmt.Errorf("删除记录失败: %v", result.Error)
        }
        
        deletedTotal += result.RowsAffected
        
        log.Info("批量清理记录",
            zap.String("table", config.TableName),
            zap.Int64("batch_deleted", result.RowsAffected),
            zap.Int64("total_deleted", deletedTotal),
        )
        
        time.Sleep(100 * time.Millisecond)
    }
    
    return nil
}
```

#### 6.6.3 定时调度器
```go
// 调度器实现
type Scheduler struct {
    cleanupService CleanupService
    configRepo     ConfigRepository
    cron           *cron.Cron
}

func NewScheduler(cleanupService CleanupService, configRepo ConfigRepository) *Scheduler {
    return &Scheduler{
        cleanupService: cleanupService,
        configRepo:     configRepo,
        cron:          cron.New(cron.WithSeconds()),
    }
}

func (s *Scheduler) Start() error {
    // 每小时检查一次清理任务
    _, err := s.cron.AddFunc("0 0 * * * *", s.checkCleanupTasks)
    if err != nil {
        return fmt.Errorf("添加定时任务失败: %v", err)
    }
    
    s.cron.Start()
    log.Info("日志清理调度器启动成功")
    return nil
}

func (s *Scheduler) Stop() {
    s.cron.Stop()
    log.Info("日志清理调度器停止")
}

func (s *Scheduler) checkCleanupTasks() {
    ctx := context.Background()
    
    // 获取所有清理配置
    configs, err := s.configRepo.GetAllConfigs(ctx)
    if err != nil {
        log.Error("获取清理配置失败", zap.Error(err))
        return
    }
    
    currentHour := time.Now().Hour()
    
    for _, config := range configs {
        if !config.Enabled {
            continue
        }
        
        // 检查是否到了清理时间
        if currentHour != config.CleanupHour {
            continue
        }
        
        // 检查今天是否已经清理过
        if s.isCleanedToday(config) {
            continue
        }
        
        log.Info("开始清理任务",
            zap.String("table", config.TableName),
            zap.Int("retention_days", config.RetentionDays),
            zap.Int("retention_count", config.RetentionCount),
        )
        
        // 执行清理任务
        go s.executeCleanup(ctx, config)
    }
}

func (s *Scheduler) executeCleanup(ctx context.Context, config *CleanupConfig) {
    startTime := time.Now()
    
    // 先按时间清理
    if err := s.cleanupService.CleanupByTime(ctx, config); err != nil {
        log.Error("按时间清理失败",
            zap.String("table", config.TableName),
            zap.Error(err),
        )
    }
    
    // 再按数量清理
    if err := s.cleanupService.CleanupByCount(ctx, config); err != nil {
        log.Error("按数量清理失败",
            zap.String("table", config.TableName),
            zap.Error(err),
        )
    }
    
    // 更新最后清理时间
    if err := s.configRepo.UpdateLastCleanupTime(ctx, config.TableName, startTime); err != nil {
        log.Error("更新清理时间失败", zap.Error(err))
    }
    
    duration := time.Since(startTime)
    log.Info("清理任务完成",
        zap.String("table", config.TableName),
        zap.Duration("duration", duration),
    )
}

func (s *Scheduler) isCleanedToday(config *CleanupConfig) bool {
    if config.LastCleanupAt == nil {
        return false
    }
    
    now := time.Now()
    lastCleanup := *config.LastCleanupAt
    
    // 检查是否是同一天
    return now.Year() == lastCleanup.Year() &&
           now.YearDay() == lastCleanup.YearDay()
}
```

#### 6.6.4 配置管理
```go
// 配置仓储接口
type ConfigRepository interface {
    GetAllConfigs(ctx context.Context) ([]*CleanupConfig, error)
    GetConfigByTable(ctx context.Context, tableName string) (*CleanupConfig, error)
    UpdateConfig(ctx context.Context, config *CleanupConfig) error
    UpdateLastCleanupTime(ctx context.Context, tableName string, cleanupTime time.Time) error
}

// 默认清理配置
var DefaultCleanupConfigs = []*CleanupConfig{
    {
        TableName:      "access_logs",
        RetentionDays:  30,    // 保留30天
        RetentionCount: 500000, // 最多保留50万条
        BatchSize:      500,    // 每次删除500条
        CleanupHour:    2,      // 凌晨2点清理
        Enabled:        true,
    },
    {
        TableName:      "delivery_order_sync",
        RetentionDays:  90,     // 保留90天
        RetentionCount: 100000, // 最多保留10万条
        BatchSize:      500,
        CleanupHour:    3,      // 凌晨3点清理
        Enabled:        true,
    },
    {
        TableName:      "commission_records",
        RetentionDays:  365,    // 保留1年
        RetentionCount: 1000000, // 最多保留100万条
        BatchSize:      500,
        CleanupHour:    4,      // 凌晨4点清理
        Enabled:        true,
    },
}
```

#### 6.6.5 监控和告警
```go
// 清理监控服务
type CleanupMonitor struct {
    db *gorm.DB
}

func NewCleanupMonitor(db *gorm.DB) *CleanupMonitor {
    return &CleanupMonitor{db: db}
}

// 生成清理报告
func (m *CleanupMonitor) GenerateCleanupReport(ctx context.Context) (*CleanupReport, error) {
    report := &CleanupReport{
        GeneratedAt: time.Now(),
        Tables:      make(map[string]*TableStats),
    }
    
    tables := []string{"access_logs", "delivery_order_sync", "commission_records"}
    
    for _, tableName := range tables {
        stats, err := m.getTableStats(ctx, tableName)
        if err != nil {
            return nil, err
        }
        report.Tables[tableName] = stats
    }
    
    return report, nil
}

func (m *CleanupMonitor) getTableStats(ctx context.Context, tableName string) (*TableStats, error) {
    stats := &TableStats{TableName: tableName}
    
    // 获取记录总数
    err := m.db.WithContext(ctx).
        Table(tableName).
        Count(&stats.TotalRecords)
    if err != nil {
        return nil, err
    }
    
    // 获取今天的记录数
    today := time.Now().Truncate(24 * time.Hour)
    err = m.db.WithContext(ctx).
        Table(tableName).
        Where("created_at >= ?", today).
        Count(&stats.TodayRecords)
    if err != nil {
        return nil, err
    }
    
    // 获取最老记录时间
    err = m.db.WithContext(ctx).
        Table(tableName).
        Order("created_at ASC").
        Limit(1).
        Pluck("created_at", &stats.OldestRecord)
    if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, err
    }
    
    // 获取表大小（估算）
    var result struct {
        TableSize int64 `gorm:"column:table_size"`
    }
    err = m.db.WithContext(ctx).Raw(`
        SELECT ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS table_size
        FROM information_schema.tables 
        WHERE table_schema = DATABASE() 
        AND table_name = ?
    `, tableName).Scan(&result).Error
    
    if err == nil {
        stats.TableSizeMB = result.TableSize
    }
    
    return stats, nil
}

type CleanupReport struct {
    GeneratedAt time.Time              `json:"generated_at"`
    Tables      map[string]*TableStats `json:"tables"`
}

type TableStats struct {
    TableName     string    `json:"table_name"`
    TotalRecords  int64     `json:"total_records"`
    TodayRecords  int64     `json:"today_records"`
    OldestRecord  time.Time `json:"oldest_record"`
    TableSizeMB   int64     `json:"table_size_mb"`
}
```

#### 6.6.6 服务配置文件
```yaml
# configs/config.yaml
server:
  name: "log-cleaner-service"
  port: 8082

database:
  host: "localhost"
  port: 3306
  username: "root"
  password: "password"
  database: "tea_db"
  max_idle_conns: 10
  max_open_conns: 100

log:
  level: "info"
  file_path: "/var/log/log-cleaner/app.log"
  max_size: 100
  max_backups: 30
  max_age: 7

cleanup:
  default_batch_size: 500
  default_retention_days: 30
  monitor_interval: "1h"
  
alert:
  enabled: true
  webhook_url: "https://hooks.slack.com/services/xxx"
  disk_usage_threshold: 80
  table_size_threshold: 1000
```

#### 6.6.7 部署和运行
```bash
# 构建服务
go build -o log-cleaner ./cmd/main.go

# 运行服务
./log-cleaner -config ./configs/config.yaml

# 或使用 systemd 服务
sudo systemctl start log-cleaner
sudo systemctl enable log-cleaner
```

这个日志清理系统具有以下特点：
1. **独立服务**：不影响主业务系统性能
2. **灵活配置**：支持按时间和数量两种清理策略
3. **批量处理**：每次删除500条，避免长时间锁表
4. **定时执行**：可配置每天的清理时间
5. **监控告警**：提供清理报告和异常告警
6. **安全可靠**：支持事务和错误重试

### 6.7 审计字段实现方案

#### 6.6.1 UID生成策略
```go
import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "time"
)

// UID生成器
type UIDGenerator struct {
    prefix string
}

func NewUIDGenerator(prefix string) *UIDGenerator {
    return &UIDGenerator{prefix: prefix}
}

// 生成32位唯一ID
func (g *UIDGenerator) Generate() string {
    // 时间戳(8位) + 随机数(20位) + 前缀(4位)
    timestamp := fmt.Sprintf("%08x", time.Now().Unix())
    
    // 生成10字节随机数，转换为20位十六进制
    randomBytes := make([]byte, 10)
    rand.Read(randomBytes)
    randomStr := hex.EncodeToString(randomBytes)
    
    // 前缀补全到4位
    prefix := fmt.Sprintf("%-4s", g.prefix)
    if len(prefix) > 4 {
        prefix = prefix[:4]
    }
    
    return timestamp + randomStr + prefix
}

// 使用示例
var (
    UserUIDGen     = NewUIDGenerator("USR")
    ProductUIDGen  = NewUIDGenerator("PRD")
    OrderUIDGen    = NewUIDGenerator("ORD")
    StoreUIDGen    = NewUIDGenerator("STR")
)
```

#### 6.6.2 GORM钩子函数实现
```go
// 创建前钩子 - 自动设置UID和创建信息
func (u *User) BeforeCreate(tx *gorm.DB) error {
    if u.UID == "" {
        u.UID = UserUIDGen.Generate()
    }
    
    // 从上下文获取操作人ID
    if operatorID := tx.Statement.Context.Value("user_id"); operatorID != nil {
        u.CreatedBy = operatorID.(uint64)
    }
    
    u.CreatedAt = time.Now()
    u.IsDeleted = 0
    return nil
}

// 更新前钩子 - 自动设置更新信息
func (u *User) BeforeUpdate(tx *gorm.DB) error {
    // 从上下文获取操作人ID
    if operatorID := tx.Statement.Context.Value("user_id"); operatorID != nil {
        u.UpdatedBy = operatorID.(uint64)
    }
    
    u.UpdatedAt = time.Now()
    return nil
}

// 软删除实现
func (u *User) Delete(tx *gorm.DB, operatorID uint64) error {
    now := time.Now()
    return tx.Model(u).Updates(map[string]interface{}{
        "is_deleted": 1,
        "deleted_at": &now,
        "updated_by": operatorID,
        "updated_at": now,
    }).Error
}
```

#### 6.6.3 通用CRUD服务
```go
// 通用仓储接口
type Repository[T any] interface {
    Create(ctx context.Context, entity *T) error
    Update(ctx context.Context, entity *T) error
    Delete(ctx context.Context, id uint64) error
    FindByID(ctx context.Context, id uint64) (*T, error)
    FindByUID(ctx context.Context, uid string) (*T, error)
    List(ctx context.Context, filter map[string]interface{}, page, size int) ([]*T, int64, error)
}

// 基础仓储实现
type BaseRepository[T any] struct {
    db *gorm.DB
}

func NewBaseRepository[T any](db *gorm.DB) *BaseRepository[T] {
    return &BaseRepository[T]{db: db}
}

func (r *BaseRepository[T]) Create(ctx context.Context, entity *T) error {
    return r.db.WithContext(ctx).Create(entity).Error
}

func (r *BaseRepository[T]) Update(ctx context.Context, entity *T) error {
    return r.db.WithContext(ctx).Save(entity).Error
}

func (r *BaseRepository[T]) Delete(ctx context.Context, id uint64) error {
    var entity T
    operatorID := ctx.Value("user_id").(uint64)
    now := time.Now()
    
    return r.db.WithContext(ctx).Model(&entity).Where("id = ?", id).Updates(map[string]interface{}{
        "is_deleted": 1,
        "deleted_at": &now,
        "updated_by": operatorID,
        "updated_at": now,
    }).Error
}

func (r *BaseRepository[T]) FindByID(ctx context.Context, id uint64) (*T, error) {
    var entity T
    err := r.db.WithContext(ctx).Where("id = ? AND is_deleted = 0", id).First(&entity).Error
    if err != nil {
        return nil, err
    }
    return &entity, nil
}

func (r *BaseRepository[T]) FindByUID(ctx context.Context, uid string) (*T, error) {
    var entity T
    err := r.db.WithContext(ctx).Where("uid = ? AND is_deleted = 0", uid).First(&entity).Error
    if err != nil {
        return nil, err
    }
    return &entity, nil
}
```

#### 6.6.4 中间件实现
```go
// 用户上下文中间件
func UserContextMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从JWT token中解析用户ID
        token := c.GetHeader("Authorization")
        if token != "" {
            claims, err := jwt.ParseToken(strings.TrimPrefix(token, "Bearer "))
            if err == nil {
                // 将用户ID存入上下文
                ctx := context.WithValue(c.Request.Context(), "user_id", claims.UserID)
                c.Request = c.Request.WithContext(ctx)
                c.Set("user_id", claims.UserID)
            }
        }
        c.Next()
    }
}

// 审计日志中间件
func AuditLogMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        // 记录操作日志
        userID, _ := c.Get("user_id")
        duration := time.Since(start)
        
        log.Info("API访问日志",
            zap.String("method", c.Request.Method),
            zap.String("path", c.Request.URL.Path),
            zap.Any("user_id", userID),
            zap.Duration("duration", duration),
            zap.Int("status", c.Writer.Status()),
        )
    }
}
```

#### 6.6.5 数据库查询优化
```go
// 软删除查询作用域
func NotDeletedScope(db *gorm.DB) *gorm.DB {
    return db.Where("is_deleted = 0")
}

// 按创建时间倒序
func OrderByCreatedDesc(db *gorm.DB) *gorm.DB {
    return db.Order("created_at DESC")
}

// 分页查询
func Paginate(page, size int) func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        if page <= 0 {
            page = 1
        }
        if size <= 0 {
            size = 10
        }
        offset := (page - 1) * size
        return db.Offset(offset).Limit(size)
    }
}

// 使用示例
func (r *UserRepository) ListUsers(ctx context.Context, page, size int) ([]*User, int64, error) {
    var users []*User
    var total int64
    
    db := r.db.WithContext(ctx).Scopes(NotDeletedScope)
    
    // 获取总数
    db.Model(&User{}).Count(&total)
    
    // 获取分页数据
    err := db.Scopes(OrderByCreatedDesc, Paginate(page, size)).Find(&users).Error
    
    return users, total, err
}
```

这个实现方案确保了：
1. **UID唯一性**：每条记录都有全局唯一的32位标识符
2. **完整审计**：记录创建人、修改人、创建时间、修改时间
3. **软删除**：通过`is_deleted`字段实现逻辑删除
4. **自动化**：通过GORM钩子自动处理审计字段
5. **性能优化**：合理的索引设计和查询优化

---

这个开发计划涵盖了茶心阁小程序项目的所有核心功能，采用单体应用架构，具备完整的审计功能和软删除机制，确保项目能够按时保质完成。