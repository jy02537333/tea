- MySQL: `root:my-secret-pw@tcp(10.8.0.3:3310)/tea_shop?charset=utf8mb4&parseTime=True&loc=Local`
- Redis: `10.8.0.3:6379` 密码 `123456`
- RabbitMQ: `amqp://guest:guest@10.8.0.3:5672/`
# wx-fe & Admin-FE 调用 tea-api 验证结果

## 验证方法

- 代码检查：逐个核对 `wx-fe/src/services/*.ts`、`admin-fe/src/services/*.ts` 中定义的 axios 封装，确认路径、HTTP 动词与 `tea-api/internal/router/router.go` 中暴露的路由一致。
- 类型检查：`pnpm --filter wx-fe run typecheck`、`pnpm --filter admin-fe run typecheck` 均通过，说明前端调用签名与当前类型定义匹配。
- 接口连通性：运行 `scripts/run_api_validation.sh` 以及若干 `curl` 取样，记录真实 HTTP 状态和响应（见 `build-ci-logs/api_validation/summary.txt`）。

## wx-fe → tea-api

| 前端入口 (文件/方法) | 调用的 tea-api 接口 | 实测状态 | 结论 |
| --- | --- | --- | --- |
| `services/api.ts` 默认基址 | 默认值现在为 `http://127.0.0.1:9292`（2025-12-03 更新） | 与 tea-api 一致 | `.env` 仍可覆盖 `VITE_API_BASE_URL`，默认开箱可直连本地后端 |
| `services/products.ts#getProducts` 等 | `GET /api/v1/products` | 200 / 空列表 | 接口可用，但需导入产品测试数据 |
| `services/products.ts#getProduct` | `GET /api/v1/products/:id` | 404（`商品不存在`） | 接口存在，需准备 ID=1 的商品后前端才能展示 |
| `services/auth.ts#getUserInfo` | `GET /api/v1/user/info` | 200，`code=1` `record not found` | 需先用 `/api/v1/user/login` 创建/绑定用户，否则用户中心不可用 |
| `services/cart.ts#listCart` | `GET /api/v1/cart` | 500（MySQL FK `fk_carts_user`） | 需要种子用户与 carts 记录；否则加入购物车流程失败 |
| `services/orders.ts#listOrders` | `GET /api/v1/orders` | 200 / 空列表 | 正常返回但暂无订单数据 |
| `services/stores.ts#listStores` | `GET /api/v1/stores` | 200 / 空列表 | 连通性正常 |
| `services/coupons.ts#grantCoupon` | `POST /api/v1/coupons/grant` | 需登录；未在本轮执行 | 代码与后台路由匹配，但依赖登录态和测试数据 |

## Admin-FE → tea-api

| 前端入口 | tea-api 接口 | 实测状态 | 结论 |
| --- | --- | --- | --- |
| `admin-fe/src/services/api.ts` | 基址默认 `http://localhost:9292` | OK | 可通过 `VITE_API_BASE_URL` 覆盖；默认值与 tea-api 一致 |
| `services/orders.ts#adminListOrders` | `GET /api/v1/admin/orders` | 200 / 空列表 | 已通过 `admin_openid` dev-login 获得真正的 `role=admin` token（保存在 `build-ci-logs/admin_login_response.json`），可直接验通所有 admin 列表接口 |
| `services/stores.ts#getStoreOrderStats` | `GET /api/v1/admin/stores/:id/orders/stats` | 200 / 零统计 | 门店 `id=1` 已种子，接口返回 0 订单但状态码 OK |
| `services/rbac.ts#listRoles` | `GET /api/v1/admin/rbac/roles` | 200 / 角色列表 | 依赖 token 中 `role=admin`，本地验证已通过 |
| `services/logs`（暂未实现文件） | `/api/v1/admin/logs/*` | 200 / 空列表 | 日志接口需要 `rbac:view`，新 token 已满足，接口可直接被前端使用 |
| `services/accrual.ts` | `/api/v1/admin/accrual/*` | 未实测，路由存在 | 需在将来按需触发，新的 token 同样可携带 `admin` 角色满足前置校验 |
| `services/payments.ts` | `/api/v1/payment/intents` / `/api/v1/payment/mock-callback` | 需登录 | 路由存在且已在 `router.go` 注册；本轮聚焦 GET 覆盖，支付流程保持后续联调 |

## 结论 & 后续动作

1. **wx-fe** 默认直连地址已改为 `http://127.0.0.1:9292`，同时已在后端种入示例分类/商品/门店（category#1、product#1、store#1），`GET /api/v1/products/:id`、`/stores` 等接口返回实体数据，购物车与用户信息在真实用户 token 下返回 200。
2. **Admin-FE** 通过 `/api/v1/user/dev-login` 获取的 `admin_openid` token（文件：`build-ci-logs/admin_login_response.json`）带有 `role=admin`，已实测 `/api/v1/admin/orders`、`/admin/stores/1/orders/stats`、`/admin/rbac/*`、`/admin/logs/operations` 均 200，可直接覆盖管理端列表与 RBAC 视图；后续如需支付、accrual 等 POST 流程，可在同一 token 下继续联调。
3. `scripts/run_api_validation.sh` 新增 `/stores`、`/coupons`、`/user/coupons` 以及多条 `/api/v1/admin/...` GET 请求，最新摘要位于 `build-ci-logs/api_validation/summary.txt`。运行脚本会顺带写出每个响应的 body 文件，便于 QA 或前端复核。

## 已完成（使用你提供的配置）

- 已将 `tea-api/configs/config.mysql.local.yaml` 更新为：
	- MySQL: host `10.8.0.3`, port `3310`, user `root`, password `my-secret-pw`, db `tea_shop`。
	- Redis: `10.8.0.3:6379`, password `123456`。
	- RabbitMQ: `10.8.0.3:5672`, guest/guest。

- 在 `tea-api` 目录运行了 SKU seeder：
	```bash
	cd tea-api
	go run scripts/seed_skus.go -product 1 -sku_name "默认规格" -sku_code "SKU-P1-001" -price "99.00" -stock 20
	```
	结果：成功创建 SKU（示例输出：`created sku id=1 product_id=1 sku_code=SKU-P1-001 ...`）。

- 验证购物车添加行为：使用已创建的 SKU（`sku_id=1`）向 `POST /api/v1/cart/items` 添加购物车条目测试通过（返回 `code=0`）。注意：如果不指定 `sku_id`，当前后端会把 0 插入到 `sku_id` 字段，MySQL 严格外键会导致失败；建议后续：
	- 前端在添加到购物车时优先传 `sku_id`，或
	- 后端在接收 `sku_id==0` 时将其写为 SQL NULL（需要修改模型或创建逻辑）。

- 进一步验证（已完成）:
	- 我已重启 `tea-api`（使用 `configs/config.mysql.local.yaml`），并运行了两次添加购物车请求：
		- 不带 `sku_id`：`POST /api/v1/cart/items`，请求体 `{ "product_id":1, "quantity":2 }`，返回 `code=0`，响应中 `sku_id` 为 `null`（保存于 `/tmp/cart_no_sku.json`）。
		- 带 `sku_id=1`：`POST /api/v1/cart/items`，请求体 `{ "product_id":1, "sku_id":1, "quantity":2 }`，返回 `code=0`（保存于 `/tmp/cart_with_sku.json`）。
	- 这证明：我已把 `CartItem.SkuID` 改为可空并更新了保存与查询逻辑，服务端现在在未传 SKU 时写入 SQL NULL，避免外键冲突。

	相关文件：`/tmp/cart_no_sku.json`、`/tmp/cart_with_sku.json`（已在运行环境中生成，用于快速确认）。

## 已保存的验证响应文件

- 我将两次购物车验证响应复制并提交到仓库：
	- `build-ci-logs/api_validation/cart_no_sku.json` （不带 `sku_id` 的请求响应，`sku_id` 为 `null`）
	- `build-ci-logs/api_validation/cart_with_sku.json` （带 `sku_id=1` 的请求响应）

- 提交信息：`chore: add cart add responses (no-sku and with-sku) from local validation`（提交短哈希：`efb2634`）。

如需我把这些响应转为更结构化的验证报告或将其纳入 CI 检查，请告诉我你偏好的格式（一页 Markdown 汇总 / JSON 报表 / HTML preview）。

> 已选择不推送并保留本地副本（此文件记录了该决策）。
